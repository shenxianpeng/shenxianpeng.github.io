<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Peter Shen</title>
  
  <subtitle>Share about CI/CD and DevOps</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shenxianpeng.github.io/"/>
  <updated>2022-06-29T01:18:11.500Z</updated>
  <id>https://shenxianpeng.github.io/</id>
  
  <author>
    <name>shenxianpeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>做爸爸了以及未来三个月陪产假期间得学习计划</title>
    <link href="https://shenxianpeng.github.io/2022/06/to-be-a-father/"/>
    <id>https://shenxianpeng.github.io/2022/06/to-be-a-father/</id>
    <published>2022-06-13T06:57:24.000Z</published>
    <updated>2022-06-29T01:18:11.500Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;感恩&quot;&gt;&lt;a href=&quot;#感恩&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="Others" scheme="https://shenxianpeng.github.io/categories/others/"/>
    
    
      <category term="Father" scheme="https://shenxianpeng.github.io/tags/father/"/>
    
  </entry>
  
  <entry>
    <title>WSL + VS Code + Docker Desktop 在 Windows 做开发还能这么爽！</title>
    <link href="https://shenxianpeng.github.io/2022/04/wsl/"/>
    <id>https://shenxianpeng.github.io/2022/04/wsl/</id>
    <published>2022-04-19T14:12:31.000Z</published>
    <updated>2022-04-19T16:17:42.840Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;许久以来，大部分程序员都遇到过在 Windows 做开发那种不便。&lt;/p&gt;
&lt;p&gt;比如不能像 Linux 和 Mac 那样只需要输入一行命令就能安装 openjdk，python，node 等等。因此有的程序员从此转到了 Mac 上开发，也有的干脆就使用 Linux
        
      
    
    </summary>
    
      <category term="Windows" scheme="https://shenxianpeng.github.io/categories/windows/"/>
    
    
      <category term="Docker" scheme="https://shenxianpeng.github.io/tags/docker/"/>
    
      <category term="WSL" scheme="https://shenxianpeng.github.io/tags/wsl/"/>
    
      <category term="VSCode" scheme="https://shenxianpeng.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>关于 Docker，containerd，CRI，CRI-O，OCI，runc 的解释以及它们是如何工作在一起的</title>
    <link href="https://shenxianpeng.github.io/2022/03/container-ecosystem/"/>
    <id>https://shenxianpeng.github.io/2022/03/container-ecosystem/</id>
    <published>2022-03-29T12:52:42.000Z</published>
    <updated>2022-03-29T16:51:53.710Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;自 Docker 开启了使用容器的爆发式增长，有越来越多的工具和标准来帮助管理和使用这项容器化技术，与此同时也造成了有很多术语让人感到困惑。&lt;/p&gt;
&lt;p&gt;比如 Docker, containerd, CRI, CRI-O, OCI, runc，本篇将介绍这些你听过但并不了解的术语，并解释容器生态系统是如何在一起工作的。&lt;/p&gt;
&lt;h2 id=&quot;容器生态系统&quot;&gt;&lt;a href=&quot;#容器生态系统&quot; class=&quot;headerlink&quot; title=&quot;容器生态系统&quot;&gt;&lt;/a&gt;容器生态系统&lt;/h2&gt;&lt;p&gt;容器生态系统是由许多令人兴奋的技术、大量的专业术语和大公司相互争斗组成的。&lt;/p&gt;
&lt;p&gt;幸运的是，这些公司偶尔会在休战中走到一起合作，商定一些标准，这些标准有助于使这个生态系统在不同的平台和操作系统之间更具互操作性，并减少对单一公司或项目的依赖。&lt;/p&gt;
&lt;p&gt;这张图显示了 Docker、Kubernetes、CRI、OCI、containerd 和 runc 在这个生态系统中是如何结合的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/container-ecosystem/container-ecosystem.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;其工作流程简单来说是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker，Kubernetes 等工具来运行一个容器时会调用容器运行时（CRI）比如 containerd，CRI-O&lt;/li&gt;
&lt;li&gt;通过容器运行时来完成容器的创建、运行、销毁等实际工作&lt;ul&gt;
&lt;li&gt;Docker 使用的是 containerd 作为其运行时；Kubernetes 支持 containerd，CRI-O 等多种容器运行时&lt;/li&gt;
&lt;li&gt;这些容器运行时都遵循了 OCI 规范，并通过 runc 来实现与操作系统内核交互来完成容器的创建和运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面就分别介绍图中所提到的术语和规范。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://shenxianpeng.github.io/categories/devops/"/>
    
    
      <category term="Docker" scheme="https://shenxianpeng.github.io/tags/docker/"/>
    
      <category term="containerd" scheme="https://shenxianpeng.github.io/tags/containerd/"/>
    
      <category term="CRI" scheme="https://shenxianpeng.github.io/tags/cri/"/>
    
      <category term="CRI-O" scheme="https://shenxianpeng.github.io/tags/cri-o/"/>
    
      <category term="OCI" scheme="https://shenxianpeng.github.io/tags/oci/"/>
    
      <category term="runc" scheme="https://shenxianpeng.github.io/tags/runc/"/>
    
  </entry>
  
  <entry>
    <title>How to enable, configure and disable Jenkins LDAP</title>
    <link href="https://shenxianpeng.github.io/2022/03/jenkins-ldap-configuration/"/>
    <id>https://shenxianpeng.github.io/2022/03/jenkins-ldap-configuration/</id>
    <published>2022-03-15T05:54:43.000Z</published>
    <updated>2022-03-15T06:46:01.207Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;In organizations, using LDAP
        
      
    
    </summary>
    
      <category term="Jenkins" scheme="https://shenxianpeng.github.io/categories/jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://shenxianpeng.github.io/tags/jenkins/"/>
    
      <category term="LDAP" scheme="https://shenxianpeng.github.io/tags/ldap/"/>
    
  </entry>
  
  <entry>
    <title>靠谱：在不删除和重建 GitHub 仓库的情况下与父(Fork)仓库分离(Unfork)</title>
    <link href="https://shenxianpeng.github.io/2022/03/unfork-github-repo/"/>
    <id>https://shenxianpeng.github.io/2022/03/unfork-github-repo/</id>
    <published>2022-03-09T03:16:05.000Z</published>
    <updated>2022-03-28T16:28:53.729Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;有开发者、甚至公司可能会遇到过以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最开始 Fork
        
      
    
    </summary>
    
      <category term="Git" scheme="https://shenxianpeng.github.io/categories/git/"/>
    
    
      <category term="Git" scheme="https://shenxianpeng.github.io/tags/git/"/>
    
      <category term="GitHub" scheme="https://shenxianpeng.github.io/tags/github/"/>
    
      <category term="Fork" scheme="https://shenxianpeng.github.io/tags/fork/"/>
    
  </entry>
  
  <entry>
    <title>在 Jenkins 上用了这么久的 Groovy，是时候认识一下它了</title>
    <link href="https://shenxianpeng.github.io/2022/03/groovy/"/>
    <id>https://shenxianpeng.github.io/2022/03/groovy/</id>
    <published>2022-03-06T14:19:31.000Z</published>
    <updated>2022-03-07T01:48:26.309Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Jenkins 和 Groovy 越久，我就这样的疑问：&lt;/p&gt;
&lt;p&gt;Groovy 到底是什么语言？&lt;br&gt;Groovy 有哪些特性？&lt;br&gt;Groovy 和 Java 有什么区别？&lt;br&gt;Groovy 和 Java 如何选择？&lt;br&gt;Groovy 在整个开发语言中占什么位置？要不要学？&lt;/p&gt;
&lt;p&gt;本篇我的学习结果的分享，希望也能帮助你解答以上的这些问题。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Groovy&quot;&gt;&lt;a href=&quot;#什么是-Groovy&quot; class=&quot;headerlink&quot; title=&quot;什么是 Groovy&quot;&gt;&lt;/a&gt;什么是 Groovy&lt;/h2&gt;&lt;p&gt;Apache Groovy 是一种强大的、可选类型的动态语言，具有静态类型和静态编译功能，适用于 Java 平台，旨在通过简洁、熟悉且易于学习的语法提高开发人员的工作效率。&lt;br&gt;它与任何 Java 程序顺利集成，并立即为你的应用程序提供强大的功能，包括脚本功能、特定领域语言创作、运行时和编译时元编程和函数式编程。&lt;/p&gt;
&lt;h2 id=&quot;Groovy-的特性&quot;&gt;&lt;a href=&quot;#Groovy-的特性&quot; class=&quot;headerlink&quot; title=&quot;Groovy 的特性&quot;&gt;&lt;/a&gt;Groovy 的特性&lt;/h2&gt;&lt;p&gt;翻译官方的说法，Groovy 有以下六大特性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;平坦的学习曲线 - 简洁、易读且富有表现力的语法，Java 开发人员易于学习&lt;/li&gt;
&lt;li&gt;强大的功能 - 闭包、构建器、运行时和编译时元编程、函数式编程、类型推断和静态编译&lt;/li&gt;
&lt;li&gt;流畅的 Java 集成 - 与 Java 和任何第三方库无缝、透明地集成和互操作&lt;/li&gt;
&lt;li&gt;领域特定语言 - 灵活可延展的语法，先进的集成和定制机制，在你的应用程序中集成可读的业务规则&lt;/li&gt;
&lt;li&gt;充满活力和丰富的生态系统 - Web 开发、响应式应用程序、并发/异步/并行库、测试框架、构建工具、代码分析、GUI 构建&lt;/li&gt;
&lt;li&gt;脚本和测试胶水 - 非常适合编写简洁和可维护的测试，以及所有构建和自动化任务&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Groovy-和-Java-的区别&quot;&gt;&lt;a href=&quot;#Groovy-和-Java-的区别&quot; class=&quot;headerlink&quot; title=&quot;Groovy 和 Java 的区别&quot;&gt;&lt;/a&gt;Groovy 和 Java 的区别&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2022/03/groovy/groovy-vs-java.png&quot; alt=&quot; Groovy vs Java&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Groovy 是一种编程语言，也支持脚本语言；Java 是一种面向对象的编程语言。&lt;/li&gt;
&lt;li&gt;Groovy 支持多方法，运行方法的选择将在运行时选择；Java 提供多方法的声明，在编译时而不是运行时选择。&lt;/li&gt;
&lt;li&gt;Groovy 中，自动资源管理机制是不存在的，静态的、匿名的内部类；Java 从 Java7 版本开始就提供了自动资源管理，在内部静态类或匿名类方面占上风。&lt;/li&gt;
&lt;li&gt;Groovy 中，有一些函数式编程特性，如 Lambda 函数，函数式接口；而 Java 从 JDK 8 版本开始就有 Lambda 函数、函数式接口和许多其他的流和并行操作功能。&lt;/li&gt;
&lt;li&gt;Groovy 可以用单引号或双引号格式定义和声明字符串和字符字面；Java 只有双引号格式来声明和定义字符串字面或字符字面。&lt;/li&gt;
&lt;li&gt;Groovy 中所有东西都是一个对象，并且只使用对象。因此，不存在自动装箱或拆箱的概念，也不存在基元的转换；相反，Java 有基元数据类型和 Wrapper 类，可以显式或隐式地进行自动装箱和自动拆箱。&lt;/li&gt;
&lt;li&gt;Groovy 中，数据类型的自动拓宽和缩小有很多宽广的范围，有很多转换；而Java在数据类型的缩小或拓宽方面有限制。&lt;/li&gt;
&lt;li&gt;Groovy 对其所有类型的类成员或数据都有一个默认的访问修饰符；而Java的默认访问级别是包级，取决于类成员的类型。&lt;/li&gt;
&lt;li&gt;Groovy 在其类中自动生成 getters 和 setter 来访问和修改类的成员；而在 Java 中，它们必须在类中明确提到访问修饰符。&lt;/li&gt;
&lt;li&gt;Groovy 有 Groovy beans；而Java有Java beans。&lt;/li&gt;
&lt;li&gt;Groovy 也被称为 Java 的超集，因为 Java 程序可以在 Groovy 环境中运行。反过来并不一定。&lt;/li&gt;
&lt;li&gt;Groovy 在定义类型时有更简单的语法，只需使用 def 来声明一个变量；Java有不同类型的类型名称来声明变量或类的任何方法或成员。&lt;/li&gt;
&lt;li&gt;Groovy 不要求任何主方法或方法的入口点来运行类或任何程序；而 Java 则要求类中的 main 方法来运行程序。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Groovy" scheme="https://shenxianpeng.github.io/categories/groovy/"/>
    
    
      <category term="Jenkins" scheme="https://shenxianpeng.github.io/tags/jenkins/"/>
    
      <category term="Java" scheme="https://shenxianpeng.github.io/tags/java/"/>
    
      <category term="Groovy" scheme="https://shenxianpeng.github.io/tags/groovy/"/>
    
  </entry>
  
  <entry>
    <title>Resolved - The Pip Inspector tree parse failed to produce output</title>
    <link href="https://shenxianpeng.github.io/2022/03/blackduck-troubleshooting/"/>
    <id>https://shenxianpeng.github.io/2022/03/blackduck-troubleshooting/</id>
    <published>2022-03-02T06:54:11.000Z</published>
    <updated>2022-03-28T16:29:16.892Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Failure: PIP - Pip Inspector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  The Pip Inspector tree parse failed to produce output.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Overall Status: FAILURE_DETECTOR - Detect had one or more detector failures &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; extracting dependencies.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;For more output please click to expand.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;👉 Click to see more output 👈&lt;/summary&gt;

&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[main] --- ======== Detect Issues ========&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- DETECTORS:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- 	Detector Issue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- 		/workdir/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- 		Failure: PIP - Pip Inspector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- 			The Pip Inspector tree parse failed to produce output.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- ======== Detect Result ========&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- Black Duck Project BOM: https://org.blackducksoftware.com/api/projects/246c8952-7cb8-40e9-9987-35f7d4602ae1/versions/e1cb4204-42d0-4445-8675-978df62b150d/components&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- ======== Detect Status ========&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- GIT: SUCCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- PIP: FAILURE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- Signature scan / Snippet scan on /workdir/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;: SUCCESS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- Overall Status: FAILURE_DETECTOR - Detect had one or more detector failures &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; extracting dependencies. Check that all projects build and your environment is configured correctly.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- If you need &lt;span class=&quot;built_in&quot;&gt;help&lt;/span&gt; troubleshooting this problem, generate a diagnostic zip file by adding &lt;span class=&quot;string&quot;&gt;&#39;-d&#39;&lt;/span&gt; to the &lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt; line, and provide it to Synopsys Technical Support. See &lt;span class=&quot;string&quot;&gt;&#39;Diagnostic Mode&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the Detect documentation &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- ===============================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- Detect duration: 00h 00m 54s 951ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- Exiting with code 5 - FAILURE_DETECTOR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/details&gt;

&lt;p&gt;ENVIRONMENT:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Product: synopsys-detect-7.11.1.jar&lt;/li&gt;
&lt;li&gt;Others: OpenJDK 11, Python 3.6 and Python 2.7.5&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Root-cause&quot;&gt;&lt;a href=&quot;#Root-cause&quot; class=&quot;headerlink&quot; title=&quot;Root cause&quot;&gt;&lt;/a&gt;Root cause&lt;/h2&gt;&lt;p&gt;More output of this run, I see it used &lt;code&gt;python&lt;/code&gt; (which is python2) not &lt;code&gt;python3&lt;/code&gt;,&lt;br&gt;so run &lt;a href=&quot;https://github.com/blackducksoftware/synopsys-detect/blob/master/src/main/resources/pip-inspector.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pip-inspector.py&lt;/a&gt; failed.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DEBUG [main-Executable_Stream_Thread] --- Python 2.7.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[main] --- Running executable &amp;gt;/usr/bin/python /home/****/blackduck/runs/2022-03-01-07-45-05-986/shared/pip/pip-inspector.py --projectname=&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;Link python to python3, it works in my case.&lt;/p&gt;
&lt;p&gt;For example&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# save python to other name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mv /usr/bin/python /usr/bin/python.old&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# link python3 to python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo ln -s /usr/bin/python3 /usr/bin/python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Then try to run &lt;code&gt;bash &amp;lt;(curl -s -L https://detect.synopsys.com/detect7.sh)&lt;/code&gt; again, my test commands:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash &amp;lt;(curl -s -L https://detect.synopsys.com/detect7.sh) --blackduck.url=https://org.blackducksoftware.com --blackduck.api.token=MmMwMjdlOTctMT --detect.project.name=HUB --detect.project.version.name=TEST_v1.1.1 --detect.source.path=/workdir/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt; --logging.level.com.synopsys.integration=DEBUG --blackduck.trust.cert=TRUE --detect.tools.excluded=POLARIS --detect.blackduck.signature.scanner.snippet.matching=SNIPPET_MATCHING&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;If you want to use Docker to do Blackduck scan, you can create a Docker image. like this&lt;/p&gt;
    
    </summary>
    
      <category term="BlackDuck" scheme="https://shenxianpeng.github.io/categories/blackduck/"/>
    
    
      <category term="Troubleshooting" scheme="https://shenxianpeng.github.io/tags/troubleshooting/"/>
    
      <category term="BlackDuck" scheme="https://shenxianpeng.github.io/tags/blackduck/"/>
    
  </entry>
  
  <entry>
    <title>2022 年最值得关注的 DevOps 趋势和问答</title>
    <link href="https://shenxianpeng.github.io/2022/02/devops-trends-2022/"/>
    <id>https://shenxianpeng.github.io/2022/02/devops-trends-2022/</id>
    <published>2022-02-24T03:27:18.000Z</published>
    <updated>2022-03-28T16:29:40.828Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;DevOps 是 IT 界最近几年的一个热门话题，而且还会越来越热。&lt;/p&gt;
&lt;p&gt;最近有幸和一位做传播咨询的读者朋友交流关于 2022 年最值得关注的 DevOps 趋势以及一些问题和回答，分享给大家。&lt;/p&gt;
&lt;h2 id=&quot;行业趋势&quot;&gt;&lt;a href=&quot;#行业趋势&quot; class=&quot;headerlink&quot; title=&quot;行业趋势&quot;&gt;&lt;/a&gt;行业趋势&lt;/h2&gt;&lt;h3 id=&quot;趋势一：转向无服务器计算&quot;&gt;&lt;a href=&quot;#趋势一：转向无服务器计算&quot; class=&quot;headerlink&quot; title=&quot;趋势一：转向无服务器计算&quot;&gt;&lt;/a&gt;趋势一：转向无服务器计算&lt;/h3&gt;&lt;p&gt;无服务器计算是一种新兴趋势，实际上已经存在了十多年。企业购买无服务器框架需要一段时间，主要是因为对行业支持和对投资回报的担忧。&lt;/p&gt;
&lt;p&gt;无服务器具有许多越来越难以忽视的优势，主要的两个最大好处是效率和可靠性。没有基础设施管理的负担，企业可以将资源集中在正重要的事项上。此外，无服务器还降低了传统框架可能出现的潜在维护问题的风险。&lt;/p&gt;
&lt;p&gt;无服务器提供固有的可扩展性和可靠性并自动化开发人员不喜欢的日常操作任务，2022 年无服务器计算会经历下一次发展。&lt;/p&gt;
&lt;h3 id=&quot;趋势二：微服务架构增长&quot;&gt;&lt;a href=&quot;#趋势二：微服务架构增长&quot; class=&quot;headerlink&quot; title=&quot;趋势二：微服务架构增长&quot;&gt;&lt;/a&gt;趋势二：微服务架构增长&lt;/h3&gt;&lt;p&gt;随着无服务器计算在 2022 年的发展，微服务也将如此。&lt;/p&gt;
&lt;p&gt;微服务架构是将单体应用分化为小的独立单元，或服务，从而为大型团队提供了更大的灵活性。它有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为企业提供比单体应用程序更好的可扩展性和敏捷性&lt;/li&gt;
&lt;li&gt;开发人员可以使用他们熟悉的编程语言和工具，消除传统应用程序开发的局限&lt;/li&gt;
&lt;li&gt;开发人员能够在不破坏整个代码库的情况下部署小的特性或功能&lt;/li&gt;
&lt;li&gt;DevOps 团队可以根据业务需求来扩展每个应用部分，而不是一次性扩展整个应用&lt;/li&gt;
&lt;li&gt;出现问题微服务可以轻松控制问题，而不会中断整个应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然也必须认识到微服务的一个弊端，如果实施不佳可能导致严重问题，包括数据丢失、可靠性差和安全风险。&lt;/p&gt;
&lt;h3 id=&quot;趋势三：Kubernetes-成为基础架构&quot;&gt;&lt;a href=&quot;#趋势三：Kubernetes-成为基础架构&quot; class=&quot;headerlink&quot; title=&quot;趋势三：Kubernetes 成为基础架构&quot;&gt;&lt;/a&gt;趋势三：Kubernetes 成为基础架构&lt;/h3&gt;&lt;p&gt;Kubernetes，也称 K8s，是容器编排开源平台，它能够与容器组交互，同时管理更多集群。除了容器管理，还提供安全、网络和存储服务，自我监控，节点和容器的健康状况检查。它可以处理从虚拟机集群管理到负载平衡等所有方方面面，提高生产力，简化 DevOps 开发、测试和部署流程。&lt;/p&gt;
&lt;p&gt;根据 Flexera 的 2021 年云计算状况报告，48% 的企业使用 Kubernetes，另有 25% 的企业计划使用它。另外 53% 的组织使用 Docker，21% 的组织计划使用。&lt;/p&gt;
&lt;h3 id=&quot;趋势四：DevSecOps-成为重要组成部分&quot;&gt;&lt;a href=&quot;#趋势四：DevSecOps-成为重要组成部分&quot; class=&quot;headerlink&quot; title=&quot;趋势四：DevSecOps 成为重要组成部分&quot;&gt;&lt;/a&gt;趋势四：DevSecOps 成为重要组成部分&lt;/h3&gt;&lt;p&gt;安全性正在成为 DevOps 领域的另一个日益关注的问题。&lt;/p&gt;
&lt;p&gt;为了避免网络攻击，许多大型企业正在将安全性集成到他们的 DevOps 流程中。从 DevOps 到 DevSecOps 的转变预计在 2022 会有更多公司在软件开发生命周期的早期加入安全控制。&lt;br&gt;这使 DevOps 团队能够在开发阶段持续监控和修复安全缺陷，从而提高交付速度和质量。DevSecOps 正在成为许多公司组织结构图的重要组成部分。&lt;/p&gt;
&lt;h2 id=&quot;行业问答&quot;&gt;&lt;a href=&quot;#行业问答&quot; class=&quot;headerlink&quot; title=&quot;行业问答&quot;&gt;&lt;/a&gt;行业问答&lt;/h2&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://shenxianpeng.github.io/categories/devops/"/>
    
    
      <category term="DevOps" scheme="https://shenxianpeng.github.io/tags/devops/"/>
    
      <category term="Kubernetes" scheme="https://shenxianpeng.github.io/tags/kubernetes/"/>
    
      <category term="DevSecOps" scheme="https://shenxianpeng.github.io/tags/devsecops/"/>
    
  </entry>
  
  <entry>
    <title>从QA到DEV到DEVOPS，码字五年有哪些收获</title>
    <link href="https://shenxianpeng.github.io/2022/02/from-qa-to-dev-to-devops/"/>
    <id>https://shenxianpeng.github.io/2022/02/from-qa-to-dev-to-devops/</id>
    <published>2022-02-20T16:15:00.000Z</published>
    <updated>2022-03-28T16:29:24.452Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在写博客和公众号这件事上，不知不觉已经是我的第五个年头了，没想过能这么久。&lt;/p&gt;
&lt;p&gt;借此分享一下这些年我的职业线路的变化，以及写博客&amp;amp;公众号有什么收获，算是自己过去的一个总结，如果能有点共鸣和帮助就更好了。&lt;/p&gt;
&lt;h2 id=&quot;从QA到DEV到DEVOPS&quot;&gt;&lt;a href=&quot;#从QA到DEV到DEVOPS&quot; class=&quot;headerlink&quot; title=&quot;从QA到DEV到DEVOPS&quot;&gt;&lt;/a&gt;从QA到DEV到DEVOPS&lt;/h2&gt;&lt;p&gt;最早关注我公众号读者朋友大概都是因为软件测试而结缘的。是的，我做了近 10 的软件测试工作，先后在 SIMcom、东软、京东商城、外企从事过功能&amp;amp;自动化&amp;amp;性能测试工作。&lt;/p&gt;
&lt;p&gt;从功能测试入行开始，我慢慢地感受到编程不是开发的独门武功，它也是测试工程师的必备技能，只有具备良好的编码能力，才能去做自动化、Unittest、以及测试开发等工作。&lt;/p&gt;
&lt;p&gt;当我做了自动化测试工程师，我又发现相对于“发现”问题，“解决”问题更令我愉悦。我开始梦想有机会能去做开发，这样不但可以提高自己的编程能力，另外开发、测试都懂也能为自己今后的职业发展找到更多可能性。&lt;/p&gt;
&lt;p&gt;最终是因为有这样的机会+自己的主动+编码过得去，我从测试转到了开发。起初的艰难和压力都是我工作近 10 年来前所未有的，白天看代码、晚上看代码、周末看代码… 天天如此。经过了半年多的努力，才终于上岸，可以做 C/C++ 项目的 Bugfix 了。&lt;/p&gt;
&lt;p&gt;也正是因为有开发、自动化、持续集成的经验，在团队需要一名 Build/Release 工程师的时候，我知道这就是我最适合的岗位，负责产品的自动化构建、发布、基础设施建设、CI/CD 以及提高研发效能的相关开发工作。&lt;/p&gt;
&lt;p&gt;就这样我从 QA 到 DEV 到 DEVOPS。公众号的更名记录也记录了我的职业路线变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2019年07月28日 “软件测试与开发”改名“DevOps攻城狮”&lt;/li&gt;
&lt;li&gt;2018年12月29日 “DevQA”改名“软件测试与开发”&lt;/li&gt;
&lt;li&gt;2018年12月26日 “软件测试QA”改名“DevQA”&lt;/li&gt;
&lt;li&gt;2017年08月01日 注册“软件测试QA”&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;写作五年有哪些收获&quot;&gt;&lt;a href=&quot;#写作五年有哪些收获&quot; class=&quot;headerlink&quot; title=&quot;写作五年有哪些收获&quot;&gt;&lt;/a&gt;写作五年有哪些收获&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;写作是一项长期收益远超短期收益的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于绝大多数人在短期内几乎不会有什么实质性的收益，还会花费大量的业余时间，妥妥的是用爱在发电。从金钱角度来衡量这件事，这是一件投入和产出完全不成比例的事情，很难坚持。&lt;/p&gt;
&lt;p&gt;如果从长期来看，坚持写作一定会带来价值的，我总结有以五个方面的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;好记性不如烂笔头 - 当我们弄明白了一个技术难题，虽然当时明白了，但如果没记录下来，很有可能以后遇到同样的问题又不知道该如何解决。&lt;/li&gt;
&lt;li&gt;让别人听懂才是真的懂 - 有时候对于一个问题我们认为自己明白了，当分享给别人的时候，才发现其中有的逻辑说不通，因此不得不继续思考并彻底搞清楚。&lt;/li&gt;
&lt;li&gt;打造学习飞轮 - 当你坚持分享并有人关注到你并与你互动的时候，你就会有动力继续分享，学习新的知识然后再分享，一旦学习的飞轮造好了，坚持下去就变得容易。&lt;/li&gt;
&lt;li&gt;间接收益 - 但凡坚持写点东西，对于以后找工作都或多或少会有些帮助，至少说明你是一个爱学习的人。如果你的分享让同行、未来你的面试官觉得很不错，很可能会给你带来一次新的工作机会。&lt;/li&gt;
&lt;li&gt;直接收益 - 直接利益包括平台流量和广告收益、以及卖专栏、做咨询等。这要求就很高了，不但需要会自媒体运营，还有要超强的输出功力，这背后就是比别人更多的付出。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Others" scheme="https://shenxianpeng.github.io/categories/others/"/>
    
    
      <category term="Thought" scheme="https://shenxianpeng.github.io/tags/thought/"/>
    
  </entry>
  
  <entry>
    <title>Vagrant 和 Docker 的区别，该如何选？</title>
    <link href="https://shenxianpeng.github.io/2022/01/vagrant-vs-docker/"/>
    <id>https://shenxianpeng.github.io/2022/01/vagrant-vs-docker/</id>
    <published>2022-02-14T00:30:00.000Z</published>
    <updated>2022-02-13T14:26:15.313Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;关于 Vagrant 的介绍，可以参看前一篇文章：&lt;a href=&quot;https://shenxianpeng.github.io/2022/01/vagrant/&quot;&gt;什么是 Vagrant? Vagrant 和 VirtualBox 的区别&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-Vagrant&quot;&gt;&lt;a href=&quot;#什么是-Vagrant&quot; class=&quot;headerlink&quot; title=&quot;什么是 Vagrant&quot;&gt;&lt;/a&gt;什么是 Vagrant&lt;/h2&gt;&lt;p&gt;关于 Vagrant 的介绍，可以参看前一篇文章：什么是 Vagrant? Vagrant 和 VirtualBox 的区别&lt;/p&gt;
&lt;h2 id=&quot;Vagrant-和-Docker-区别&quot;&gt;&lt;a href=&quot;#Vagrant-和-Docker-区别&quot; class=&quot;headerlink&quot; title=&quot;Vagrant 和 Docker 区别&quot;&gt;&lt;/a&gt;Vagrant 和 Docker 区别&lt;/h2&gt;&lt;p&gt;关于 Vagrant 被问到最多的问题：Vagrant 和 Docker 之间有什么区别。&lt;/p&gt;
&lt;p&gt;如果不分场景的直接比对 Vagrant 和 Docker 是不恰当的。在一些简单场景中，它们的作用是重复的，但在更多场景中，它们是无法相互替代的。&lt;/p&gt;
&lt;p&gt;那么什么情况下应该用 Vagrant，什么情况下用 Docker 呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以如果你仅仅是想管理虚拟机，那么你应该使用 Vagrant；如果你想快速开发和部署应用，那么应该使用 Docker。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面具体来说说为什么。&lt;/p&gt;
&lt;p&gt;Vagrant 是 VM 的管理工具，或是说编排工具；Docker 是用来构建、运行、管理容器的工具。那么这个问题其实落在了虚拟机（VM）和 容器（Container）的区别。&lt;/p&gt;
&lt;p&gt;引用网络上一组照片来感受一下物理机（Host），虚拟机（VM）和 容器（Container）之间的区别。&lt;/p&gt;
&lt;p&gt;物理机（Host）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/vagrant-vs-docker/host.jpg&quot; alt=&quot;物理机&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟机（VM）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/vagrant-vs-docker/vm.jpg&quot; alt=&quot;虚拟机&quot;&gt;&lt;/p&gt;
&lt;p&gt;容器（Container）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/vagrant-vs-docker/docker.jpg&quot; alt=&quot;Docker&quot;&gt;&lt;/p&gt;
&lt;p&gt;从图上我们更容易理解虚拟机（VM）和容器（Container）的这些不同：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;虚拟机&lt;/th&gt;
&lt;th&gt;容器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;隔离级别&lt;/td&gt;
&lt;td&gt;操作系统级&lt;/td&gt;
&lt;td&gt;进程级别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;隔离策略&lt;/td&gt;
&lt;td&gt;Hypervisor&lt;/td&gt;
&lt;td&gt;CGROUPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统资源&lt;/td&gt;
&lt;td&gt;5 - 15%&lt;/td&gt;
&lt;td&gt;0 - 5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;启动时间&lt;/td&gt;
&lt;td&gt;分钟级&lt;/td&gt;
&lt;td&gt;秒级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;镜像存储&lt;/td&gt;
&lt;td&gt;GB&lt;/td&gt;
&lt;td&gt;MB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;总结：Vagrant 和 Docker 的使用场景区别&lt;/p&gt;
    
    </summary>
    
      <category term="Vagrant" scheme="https://shenxianpeng.github.io/categories/vagrant/"/>
    
    
      <category term="Docker" scheme="https://shenxianpeng.github.io/tags/docker/"/>
    
      <category term="VirtualBox" scheme="https://shenxianpeng.github.io/tags/virtualbox/"/>
    
      <category term="Vagrant" scheme="https://shenxianpeng.github.io/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>什么是 Vagrant? Vagrant 和 VirtualBox 的区别</title>
    <link href="https://shenxianpeng.github.io/2022/01/vagrant/"/>
    <id>https://shenxianpeng.github.io/2022/01/vagrant/</id>
    <published>2022-02-11T00:30:00.000Z</published>
    <updated>2022-02-13T14:25:12.877Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Vagrant&quot;&gt;&lt;a href=&quot;#什么是-Vagrant&quot; class=&quot;headerlink&quot; title=&quot;什么是 Vagrant&quot;&gt;&lt;/a&gt;什么是 Vagrant&lt;/h2&gt;&lt;p&gt;Vagrant 是一种&lt;a href=&quot;https://github.com/hashicorp/vagrant&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开源&lt;/a&gt;软件产品，用来方便构建和维护虚拟软件开发环境。&lt;/p&gt;
&lt;p&gt;例如，它可以基于 VirtualBox、VMware、KVM、Hyper-V 和 AWS 甚至是 Docker 等提供商来构建开发环境。它通过简化虚拟化的软件配置管理，来提高开发效率。&lt;/p&gt;
&lt;p&gt;Vagrant 是用 Ruby 语言开发的，但它的生态系统支持使用其他几种语言进行开发。&lt;/p&gt;
&lt;p&gt;简单来说 Vagrant 是对传统虚拟机的一层封装，能够让你更方便的使用虚拟开发环境。&lt;/p&gt;
&lt;h2 id=&quot;Vagrant-的发展史&quot;&gt;&lt;a href=&quot;#Vagrant-的发展史&quot; class=&quot;headerlink&quot; title=&quot;Vagrant 的发展史&quot;&gt;&lt;/a&gt;Vagrant 的发展史&lt;/h2&gt;&lt;p&gt;Vagrant 最初是由 &lt;a href=&quot;https://www.hashicorp.com/about?name=mitchell-hashimoto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mitchell Hashimoto&lt;/a&gt; 于 2010 年 1 月作为个人项目启动的。&lt;/p&gt;
&lt;p&gt;Vagrant 的第一个版本于 2010 年 3 月发布。2010 年 10 月，Engine Yard 宣布他们将赞助 Vagrant 项目。&lt;/p&gt;
&lt;p&gt;Vagrant 的第一个稳定版本 Vagrant 1.0 于 2012 年 3 月发布，正好是原始版本发布两年后。&lt;/p&gt;
&lt;p&gt;同年 11 月，Mitchell 成立了 HashiCorp 公司，以支持 Vagrant 的全职开发。Vagrant 仍然是开源软件，HashiCorp 公司致力于创建商业版本，并为 Vagrant 提供专业支持和培训。&lt;/p&gt;
&lt;p&gt;现在 HashiCorp 已经成为世界顶级开源公司，它通过一系列的产品，包括 Vagrant，Packer（打包），Momad（部署），Terraform（配置云环境），Vault（权限管理） 以及 Consul（监控），从端到端重新定义了整个 DevOps。&lt;/p&gt;
&lt;p&gt;Vagrant 最初支持 VirtualBox，在 1.1 版增加了对其他虚拟化软件（如 VMware 和 KVM）的支持，以及对 Amazon EC2 等服务器环境的支持。从 1.6 版开始，Vagrant 原生支持 Docker 容器，在某些情况下可以替代完全虚拟化的操作系统。&lt;/p&gt;
&lt;h2 id=&quot;如何使用-Vagrant&quot;&gt;&lt;a href=&quot;#如何使用-Vagrant&quot; class=&quot;headerlink&quot; title=&quot;如何使用 Vagrant&quot;&gt;&lt;/a&gt;如何使用 Vagrant&lt;/h2&gt;&lt;p&gt;使用 Vagrant 的前提条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 Vagrant。下载 &lt;a href=&quot;https://www.vagrantup.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vagrant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装 &lt;a href=&quot;https://www.virtualbox.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualBox&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当以上两个都准备好了，你就可以通过命令行创建并使用你的虚拟机了。&lt;/p&gt;
&lt;p&gt;比如你需要一个 &lt;a href=&quot;https://app.vagrantup.com/hashicorp/boxes/bionic64&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu 18.04 LTS 64-bit&lt;/a&gt;的虚拟机。更多其他的虚拟机可以到 &lt;a href=&quot;https://app.vagrantup.com/boxes/search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Box&lt;/a&gt; 网站上去搜索查找，它类似于 Docker Hub，用户可以在上面下载和上传各种 Vagrant Box。&lt;/p&gt;
&lt;p&gt;你只需执行一些简单的命令就可以完成启动、登录、退出、及销毁。&lt;/p&gt;
&lt;p&gt;初始化 Vagrant&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant init hashicorp/bionic64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;启动虚拟机。大概几十秒钟就可以完成了（第一次需要下载镜像，时间会长一点，取决于网速）。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant up&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;登录你的虚拟机，然后可以使用你创建的 Ubuntu 虚拟机了&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant ssh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当你不想用的时候，执行 &lt;code&gt;logout&lt;/code&gt; 就可以退出登录了。&lt;/p&gt;
&lt;h2 id=&quot;Vagrant-和传统虚拟机软件的区别&quot;&gt;&lt;a href=&quot;#Vagrant-和传统虚拟机软件的区别&quot; class=&quot;headerlink&quot; title=&quot;Vagrant 和传统虚拟机软件的区别&quot;&gt;&lt;/a&gt;Vagrant 和传统虚拟机软件的区别&lt;/h2&gt;
    
    </summary>
    
      <category term="Vagrant" scheme="https://shenxianpeng.github.io/categories/vagrant/"/>
    
    
      <category term="VirtualBox" scheme="https://shenxianpeng.github.io/tags/virtualbox/"/>
    
      <category term="Vagrant" scheme="https://shenxianpeng.github.io/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>什么是 Go ？Go 的优势和现状。初学者应该学习 Python 还是 Go？</title>
    <link href="https://shenxianpeng.github.io/2022/01/what-is-go/"/>
    <id>https://shenxianpeng.github.io/2022/01/what-is-go/</id>
    <published>2022-01-18T14:01:31.000Z</published>
    <updated>2022-01-28T08:29:18.504Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Go 是一种开源编程语言，可以轻松构建简单、可靠和高效的软件。&lt;/p&gt;
&lt;h2 id=&quot;Go-还是-Golang&quot;&gt;&lt;a href=&quot;#Go-还是-Golang&quot; class=&quot;headerlink&quot; title=&quot;Go 还是 Golang&quot;&gt;&lt;/a&gt;Go 还是 Golang&lt;/h2&gt;&lt;p&gt;先问一个大多数人可能会忽略的问题：Google 的这门开源编程语言叫 Go 还是 Golang？还是两个都行？给你三秒钟想一下 …&lt;/p&gt;
&lt;p&gt;Google 说：它叫 Go。之所以有人称它为 Golang 是由于之前的 Go 语言官网是 golang.org（因为 go.org 已经被别人用了），因此有人将 Golang 和 Go 混用了。&lt;/p&gt;
&lt;p&gt;现在输入 golang.org 会直接跳转到 go.dev 这个网址，这也算是彻底给自家孩子正个名。&lt;/p&gt;
&lt;h2 id=&quot;Go-语言有哪些优势&quot;&gt;&lt;a href=&quot;#Go-语言有哪些优势&quot; class=&quot;headerlink&quot; title=&quot;Go 语言有哪些优势&quot;&gt;&lt;/a&gt;Go 语言有哪些优势&lt;/h2&gt;&lt;p&gt;官网是这样介绍 Go 语言的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go 适合大规模快速构建，可靠、高效的软件&lt;/li&gt;
&lt;li&gt;Go 是 Google 在背后支持的一门开源编程语言&lt;/li&gt;
&lt;li&gt;易于学习和入门&lt;/li&gt;
&lt;li&gt;内置并发和强大的标准库&lt;/li&gt;
&lt;li&gt;不断发展的合作伙伴、社区和工具生态系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天，Go 被用于各种应用程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go 在基于云或服务器端的应用程序中很受欢迎&lt;/li&gt;
&lt;li&gt;云基础设施方面。当今最流行的基础设施工具是用 Go 编写的，例如 Kubernetes、Docker 和 Prometheus&lt;/li&gt;
&lt;li&gt;许多命令行工具都是用 Go 编写的&lt;/li&gt;
&lt;li&gt;DevOps 和 Web 可靠性自动化也常常用 Go 来写&lt;/li&gt;
&lt;li&gt;Go 也被用于人工智能和数据科学领域&lt;/li&gt;
&lt;li&gt;微控制器编程、机器人技术和游戏中使用也会使用 Go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也就是为什么 Go 越来越流行。&lt;/p&gt;
&lt;p&gt;正是因为这些优势以及在工作上的需要写一个 CLI，我就入门 Go 语言了。&lt;/p&gt;
&lt;h2 id=&quot;Go-语言的排名&quot;&gt;&lt;a href=&quot;#Go-语言的排名&quot; class=&quot;headerlink&quot; title=&quot;Go 语言的排名&quot;&gt;&lt;/a&gt;Go 语言的排名&lt;/h2&gt;&lt;p&gt;Go 语言在国内热度可谓是非常高了，我们来看看 Go 语言目前最新的排名怎么样。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://shenxianpeng.github.io/categories/go/"/>
    
    
      <category term="Go" scheme="https://shenxianpeng.github.io/tags/go/"/>
    
      <category term="CLI" scheme="https://shenxianpeng.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>你一定要了解这 17 条 Docker 最佳实践！</title>
    <link href="https://shenxianpeng.github.io/2022/01/docker-best-practice/"/>
    <id>https://shenxianpeng.github.io/2022/01/docker-best-practice/</id>
    <published>2022-01-12T04:18:16.000Z</published>
    <updated>2022-01-28T06:04:47.751Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本篇分享在编写 Dockerfiles 和使用 Docker 时应遵循的一些最佳实践。篇幅较长，建议先收藏慢慢看，保证看完会很有收获。&lt;/p&gt;
&lt;h2 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h2&gt;&lt;p&gt;Dockerfile 最佳实践&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用多阶段的构建&lt;/li&gt;
&lt;li&gt;调整 Dockerfile 命令的顺序&lt;/li&gt;
&lt;li&gt;使用小型 Docker 基础镜像&lt;/li&gt;
&lt;li&gt;尽量减少层的数量&lt;/li&gt;
&lt;li&gt;使用无特权的容器&lt;/li&gt;
&lt;li&gt;优先选择 &lt;code&gt;COPY&lt;/code&gt; 而不是 &lt;code&gt;ADD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;Python&lt;/code&gt; 包缓存到 Docker 主机上&lt;/li&gt;
&lt;li&gt;每个容器只运行一个进程&lt;/li&gt;
&lt;li&gt;优先选择数组而不是字符串语法&lt;/li&gt;
&lt;li&gt;理解 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 和 &lt;code&gt;CMD&lt;/code&gt; 之间的区别&lt;/li&gt;
&lt;li&gt;添加健康检查 &lt;code&gt;HEALTHCHECK&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Docker 镜像最佳实践&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker 镜像的版本&lt;/li&gt;
&lt;li&gt;不要在镜像中存储密钥&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;.dockerignore&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;检查和扫描你的 Docker 文件和镜像&lt;/li&gt;
&lt;li&gt;签署和验证镜像&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Dockerfile-最佳实践&quot;&gt;&lt;a href=&quot;#Dockerfile-最佳实践&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile 最佳实践&quot;&gt;&lt;/a&gt;Dockerfile 最佳实践&lt;/h2&gt;&lt;h3 id=&quot;1-使用多阶段的构建&quot;&gt;&lt;a href=&quot;#1-使用多阶段的构建&quot; class=&quot;headerlink&quot; title=&quot;1. 使用多阶段的构建&quot;&gt;&lt;/a&gt;1. 使用多阶段的构建&lt;/h3&gt;&lt;p&gt;利用多阶段构建的优势来创建更精简、更安全的Docker镜像。多阶段 Docker 构建(&lt;a href=&quot;https://docs.docker.com/develop/develop-images/multistage-build/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;multi-stage builds&lt;/a&gt;)允许你将你的 Dockerfile 分成几个阶段。&lt;/p&gt;
&lt;p&gt;例如，你可以有一个阶段用于编译和构建你的应用程序，然后可以复制到后续阶段。由于只有最后一个阶段被用来创建镜像，与构建应用程序相关的依赖关系和工具就会被丢弃，因此可以留下一个精简的、模块化的、可用于生产的镜像。&lt;/p&gt;
&lt;p&gt;Web 开发示例：&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://shenxianpeng.github.io/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://shenxianpeng.github.io/tags/docker/"/>
    
      <category term="Dokerfile" scheme="https://shenxianpeng.github.io/tags/dokerfile/"/>
    
  </entry>
  
  <entry>
    <title>2022年序员如何选择显示器？1080p还是2K? 单屏还是多屏？</title>
    <link href="https://shenxianpeng.github.io/2021/12/choose-monitor/"/>
    <id>https://shenxianpeng.github.io/2021/12/choose-monitor/</id>
    <published>2021-12-21T13:19:26.000Z</published>
    <updated>2021-12-21T15:04:34.673Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;工作十几年用过了不少显示器，从最初的 17寸，到后来的 23寸、27寸、32寸、再到现在的 34 寸，根据我自己的使用体验，来个主观推荐：&lt;/p&gt;
&lt;p&gt;第一名，一个34寸曲面显示器&lt;br&gt;第二名，一个27寸 + 一个23寸的双屏组合&lt;br&gt;第三名，一个32寸 + 一个23寸的双屏组合&lt;br&gt;第三名，两个 23 寸的双屏组合（并列第三名）&lt;/p&gt;
&lt;p&gt;以上这些屏幕推荐购买 2K 及以上的分辨率，1080p 的分辨率不推荐。&lt;/p&gt;
&lt;p&gt;下面我就按照时间轴说说我用过的那些显示器。&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://shenxianpeng.github.io/categories/others/"/>
    
    
      <category term="Monitor" scheme="https://shenxianpeng.github.io/tags/monitor/"/>
    
  </entry>
  
  <entry>
    <title>组织内如何评估 CI/CD 成熟度</title>
    <link href="https://shenxianpeng.github.io/2021/12/cicd-assessment/"/>
    <id>https://shenxianpeng.github.io/2021/12/cicd-assessment/</id>
    <published>2021-12-07T14:02:53.000Z</published>
    <updated>2021-12-21T15:07:21.920Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在一个组织内，不同的团队之间可能会有不同的维度来评估 CI/CD 的成熟度。这使得对衡量每个团队的 CI/CD
        
      
    
    </summary>
    
      <category term="DevOps" scheme="https://shenxianpeng.github.io/categories/devops/"/>
    
    
      <category term="CI" scheme="https://shenxianpeng.github.io/tags/ci/"/>
    
      <category term="CD" scheme="https://shenxianpeng.github.io/tags/cd/"/>
    
      <category term="Badge" scheme="https://shenxianpeng.github.io/tags/badge/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 还能这么玩？自动将发布的博客文章更新到 GitHub 个人主页</title>
    <link href="https://shenxianpeng.github.io/2021/11/special-repository/"/>
    <id>https://shenxianpeng.github.io/2021/11/special-repository/</id>
    <published>2021-11-09T14:02:15.000Z</published>
    <updated>2021-11-30T02:47:20.803Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近实现了一个很有意思的 Workflow，就是通过 GitHub Actions 自动将每次最新发布的文章自动同步到我的 GitHub 首页。&lt;/p&gt;
&lt;p&gt;就像这样在首页显示最近发布的博客文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/11/special-repository/final.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;要实现这样的工作流需要了解以下这几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要创建一个与 GitHub 同名的个人仓库，这个仓库的 &lt;code&gt;README.md&lt;/code&gt; 信息会显示在首页&lt;/li&gt;
&lt;li&gt;通过 GitHub Actions 自动获取博客的最新文章并更新 &lt;code&gt;README.md&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只有当有新的文章发布的时候才触发自动获取、更新文章 GitHub Action&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://shenxianpeng.github.io/categories/devops/"/>
    
    
      <category term="GitHub" scheme="https://shenxianpeng.github.io/tags/github/"/>
    
      <category term="Actions" scheme="https://shenxianpeng.github.io/tags/actions/"/>
    
  </entry>
  
  <entry>
    <title>2021-22 世界质量报告（World Quality Report）</title>
    <link href="https://shenxianpeng.github.io/2021/11/world-quality-report/"/>
    <id>https://shenxianpeng.github.io/2021/11/world-quality-report/</id>
    <published>2021-11-06T07:57:10.000Z</published>
    <updated>2021-11-22T14:45:37.084Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2021-22 世界质量报告（World Quality Report 简称 WQR）是由 Micro Focus，Capgemini 和 Sogeti 三家公司合作的来分析软件质量和测试趋势在全球范围内唯一的报告。&lt;/p&gt;
&lt;p&gt;这份报告共采访了 1750 名高管和专业人士。从最高管理层到 QA 测试经理和质量工程师，涵盖了来自全球 32 个国家的 10 个行业。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/11/world-quality-report/0.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;世界质量报告（WQR）是一项独一无二的全球研究，今年的调查强调了新部署方法中不断变化的受大流行影响的应用程序需求的影响，以及 QA 对敏捷和 DevOps 实践的采用，AI 的持续增长。&lt;/p&gt;
&lt;p&gt;作为测试关注这类软件质量报告可以帮助我们快速了解软件测试行业的现状和趋势。&lt;/p&gt;
&lt;h2 id=&quot;五大主题&quot;&gt;&lt;a href=&quot;#五大主题&quot; class=&quot;headerlink&quot; title=&quot;五大主题&quot;&gt;&lt;/a&gt;五大主题&lt;/h2&gt;&lt;p&gt;WQR 的一个关键信息：在新冠疫情依旧的今天，我们看到了数字化转型的融合以及敏捷和 DevOps 实践的实时采用。此外，QA 正在成为采用敏捷和 DevOps 实践的领导者，为团队提供工具和流程以促进整个软件生命周期（SDLC）的质量。&lt;/p&gt;
&lt;p&gt;WQR 围绕关键发现和趋势突出了五个特定主题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新冠疫情对 QA 组织和软件测试的影响&lt;/li&gt;
&lt;li&gt;数字化转型与 DevOps 和敏捷采用的实时融合以及 QA 在其中的日益重要的作用&lt;/li&gt;
&lt;li&gt;地理上分散的团队在跨环境部署应用程序时专注于业务成果&lt;/li&gt;
&lt;li&gt;人工智能 (AI) 增强了敏捷和 DevOps 在所有团队中培养不断增长的质量责任文化&lt;/li&gt;
&lt;li&gt;使用 AI 驱动的持续测试和质量管理工具来解决客户体验优先事项和快速变化的受疫情影响的要求&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Quality" scheme="https://shenxianpeng.github.io/categories/quality/"/>
    
    
      <category term="Report" scheme="https://shenxianpeng.github.io/tags/report/"/>
    
      <category term="Quality" scheme="https://shenxianpeng.github.io/tags/quality/"/>
    
  </entry>
  
  <entry>
    <title>Polaris - 静态代码分析</title>
    <link href="https://shenxianpeng.github.io/2021/10/what-is-polaris/"/>
    <id>https://shenxianpeng.github.io/2021/10/what-is-polaris/</id>
    <published>2021-10-24T13:33:53.000Z</published>
    <updated>2021-11-22T15:46:11.927Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这可能是中文网里介绍Polaris最详细的文章了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是-Polaris？&quot;&gt;&lt;a href=&quot;#什么是-Polaris？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Polaris？&quot;&gt;&lt;/a&gt;什么是 Polaris？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Polaris&lt;/strong&gt; - 托管静态应用程序软件测试(SAST)工具的 SaaS 平台，它是用于分类和修复漏洞并运行报告的 Web 站点。&lt;br&gt;&lt;strong&gt;SAST&lt;/strong&gt; - 一种对源代码分析或构建过程中去寻找安全漏洞的工具，是一种在软件开发的生命周期(SDLC)中确保安全的重要步骤。&lt;br&gt;&lt;strong&gt;Coverity&lt;/strong&gt; - Coverity 是 Synopsys 公司提供的原始静态应用软件测试 (SAST) 工具。Polaris 是 Coverity 的 SaaS 版本。&lt;br&gt;&lt;strong&gt;Synopsys&lt;/strong&gt; - 是开发 Polaris 和其他软件扫描工具的公司，比如 BlackDuck 也是他们的产品。&lt;/p&gt;
&lt;h2 id=&quot;Polaris-支持哪些语言？&quot;&gt;&lt;a href=&quot;#Polaris-支持哪些语言？&quot; class=&quot;headerlink&quot; title=&quot;Polaris 支持哪些语言？&quot;&gt;&lt;/a&gt;Polaris 支持哪些语言？&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C&amp;#x2F;C++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JavaScript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TypeScript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PHP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Python&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fortran&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...and more&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;Polaris-SaaS-平台&quot;&gt;&lt;a href=&quot;#Polaris-SaaS-平台&quot; class=&quot;headerlink&quot; title=&quot;Polaris SaaS 平台&quot;&gt;&lt;/a&gt;Polaris SaaS 平台&lt;/h2&gt;&lt;p&gt;通常如果你的组织引入了 Polaris 的 SaaS 服务，你将会有如下网址可供访问 URL: &lt;a href=&quot;https://organization.polaris.synopsys.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://organization.polaris.synopsys.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后登录，你就可以给自己的 Git Repository 创建对应的项目了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建议：创建的项目名称与 Git Repository 的名称一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Polaris-如何进行漏洞扫描？&quot;&gt;&lt;a href=&quot;#Polaris-如何进行漏洞扫描？&quot; class=&quot;headerlink&quot; title=&quot;Polaris 如何进行漏洞扫描？&quot;&gt;&lt;/a&gt;Polaris 如何进行漏洞扫描？&lt;/h2&gt;&lt;h3 id=&quot;Polaris-安装&quot;&gt;&lt;a href=&quot;#Polaris-安装&quot; class=&quot;headerlink&quot; title=&quot;Polaris 安装&quot;&gt;&lt;/a&gt;Polaris 安装&lt;/h3&gt;&lt;p&gt;在进行 Polaris 扫描之前，你需要先下载并安装 polaris。&lt;/p&gt;
&lt;p&gt;如果你的 Polaris server URL 为：&lt;code&gt;POLARIS_SERVER_URL=https://organization.polaris.synopsys.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载连接为：&lt;code&gt;$POLARIS_SERVER_URL/api/tools/polaris_cli-linux64.zip&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后将下载到本地的 &lt;code&gt;polaris_cli-linux64.zip&lt;/code&gt; 进行解压，将其 bin 目录添加到 PATH 中。&lt;/p&gt;
&lt;h3 id=&quot;Polaris-YAML-文件配置&quot;&gt;&lt;a href=&quot;#Polaris-YAML-文件配置&quot; class=&quot;headerlink&quot; title=&quot;Polaris YAML 文件配置&quot;&gt;&lt;/a&gt;Polaris YAML 文件配置&lt;/h3&gt;&lt;p&gt;在进行扫描之前，你需要为你的项目创建 YAML 文件。默认配置文件名为 &lt;code&gt;polaris.yml&lt;/code&gt;，位于项目根目录。如果你希望指定不同的配置文件名，你可以在 &lt;code&gt;polaris&lt;/code&gt; 命令中使用 &lt;code&gt;-c&lt;/code&gt; 选项。&lt;/p&gt;
&lt;p&gt;在项目根目录运行 &lt;code&gt;polaris setup&lt;/code&gt; 以生成通用的 &lt;code&gt;polaris.yml&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;polaris configure&lt;/code&gt; 以确认你的文件在语法上是正确的并且 &lt;code&gt;polaris&lt;/code&gt; 没有任何问题。&lt;/p&gt;
&lt;h4 id=&quot;Capture-捕获&quot;&gt;&lt;a href=&quot;#Capture-捕获&quot; class=&quot;headerlink&quot; title=&quot;Capture - 捕获&quot;&gt;&lt;/a&gt;Capture - 捕获&lt;/h4&gt;&lt;p&gt;YAML 配置文件可以包含三种类型的 Capture：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build(构建) - 运行构建命令，然后分析结果&lt;/li&gt;
&lt;li&gt;Filesystem(文件系统) - 对于解释型语言，提供项目类型和要分析的扩展列表&lt;/li&gt;
&lt;li&gt;Buildless - 对于一些可以使用依赖管理器的语言，比如 maven&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Languages&lt;/th&gt;
&lt;th&gt;Build Options&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;C, C++, ObjectiveC, Objective C++,Go, Scala, Swift&lt;/td&gt;
&lt;td&gt;使用 Build 捕获&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PHP, Python, Ruby&lt;/td&gt;
&lt;td&gt;使用 Buildless 或 Filesystem 捕获&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C#, Visual Basic.&lt;/td&gt;
&lt;td&gt;如果想获得更准确的结果使用 Build 捕获；如果寻求简单使用 Buildless 捕获&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;如果想获得更准确的结果使用 Build 捕获；如果寻求简单使用 Buildless 捕获&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript,TypeScript&lt;/td&gt;
&lt;td&gt;使用 Filesystem 捕获；如果寻求简单使用 Buildless 捕获&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&quot;Analyze-分析&quot;&gt;&lt;a href=&quot;#Analyze-分析&quot; class=&quot;headerlink&quot; title=&quot;Analyze - 分析&quot;&gt;&lt;/a&gt;Analyze - 分析&lt;/h4&gt;&lt;p&gt;如果你正在扫描 C/C++ 代码，则应包括此分析部分以充分利用 Polaris 的扫描功能：&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;analyze:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;mode:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;central&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;coverity:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;cov-analyze:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;[&quot;--security&quot;,&quot;--concurrency&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;Polaris-YAML-示例文件&quot;&gt;&lt;a href=&quot;#Polaris-YAML-示例文件&quot; class=&quot;headerlink&quot; title=&quot;Polaris YAML 示例文件&quot;&gt;&lt;/a&gt;Polaris YAML 示例文件&lt;/h4&gt;
    
    </summary>
    
      <category term="Polaris" scheme="https://shenxianpeng.github.io/categories/polaris/"/>
    
    
      <category term="Polaris" scheme="https://shenxianpeng.github.io/tags/polaris/"/>
    
      <category term="Static" scheme="https://shenxianpeng.github.io/tags/static/"/>
    
      <category term="Coverity" scheme="https://shenxianpeng.github.io/tags/coverity/"/>
    
      <category term="Security" scheme="https://shenxianpeng.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令备忘录</title>
    <link href="https://shenxianpeng.github.io/2021/10/git-cheatsheet/"/>
    <id>https://shenxianpeng.github.io/2021/10/git-cheatsheet/</id>
    <published>2021-10-23T11:40:06.000Z</published>
    <updated>2021-11-22T15:24:03.032Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;不管是对于 Git 的初学者还是经常使用 Git 的码农们，在日常工作中难免会有遇到有的命令一时想不起来。不妨将下面总结的一些 Git 常用命令及技巧收藏或打印出来，以备需要的时候可以很快找到。&lt;/p&gt;
&lt;h2 id=&quot;git-config&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="Git" scheme="https://shenxianpeng.github.io/categories/git/"/>
    
    
      <category term="Git" scheme="https://shenxianpeng.github.io/tags/git/"/>
    
      <category term="Cheatsheet" scheme="https://shenxianpeng.github.io/tags/cheatsheet/"/>
    
  </entry>
  
  <entry>
    <title>How does SonarQube Community Edition integrate with the project</title>
    <link href="https://shenxianpeng.github.io/2021/09/sonarqube-integration/"/>
    <id>https://shenxianpeng.github.io/2021/09/sonarqube-integration/</id>
    <published>2021-09-18T02:19:51.000Z</published>
    <updated>2021-11-22T14:33:25.437Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;After you have set up the SonarQube instance, you will need to integrate SonarQube with project.&lt;/p&gt;
&lt;p&gt;Because I used the community
        
      
    
    </summary>
    
      <category term="SonarQube" scheme="https://shenxianpeng.github.io/categories/sonarqube/"/>
    
    
      <category term="Gradle" scheme="https://shenxianpeng.github.io/tags/gradle/"/>
    
      <category term="SonarQube" scheme="https://shenxianpeng.github.io/tags/sonarqube/"/>
    
  </entry>
  
</feed>
