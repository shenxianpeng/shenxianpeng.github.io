{"title":"使用 Gcov 和 LCOV 做 C/C++ 项目的代码覆盖率","slug":"2021/08/gcov-example-cn","date":"2021-08-16T16:10:21.000Z","updated":"2025-07-13T18:21:20.830Z","comments":true,"path":"api/articles/2021/08/gcov-example-cn.json","excerpt":"本篇分享如何使用 Gcov 和 LCOV 对 C&#x2F;C++ 项目进行代码覆盖率的度量。如果你想了解代码覆盖率工具 Gcov 是如何工作的，或是以后需要做 C&#x2F;C++ 项目的代码覆盖率，希望本篇对你有所帮助。","covers":["/2021/08/gcov-example-cn/gcov-flow.jpg","/2021/08/gcov-example-cn/index.png","/2021/08/gcov-example-cn/example.png","/2021/08/gcov-example-cn/main.c.png","/2021/08/gcov-example-cn/foo.c.png"],"content":"<p>本篇分享如何使用 Gcov 和 LCOV 对 C&#x2F;C++ 项目进行代码覆盖率的度量。</p>\n<p>如果你想了解代码覆盖率工具 Gcov 是如何工作的，或是以后需要做 C&#x2F;C++ 项目的代码覆盖率，希望本篇对你有所帮助。</p>\n<span id=\"more\"></span>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>不知道你没有遇到过和我一样的问题：几十年前的 C&#x2F;C++ 项目没有单元测试，只有回归测试，但是想知道回归测试测了哪些代码？还有哪些代码没测到？代码覆盖率是多少？今后哪些地方需要提高自动化测试用例？</p>\n<p>可能对于接触过 Java 的 Junit 和 JaCoCo 的人来说，没有单元测试应该测不了代码覆盖率吧 … 其实不然，如果不行就没有下文了 :)</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>市场上有一些工具可以针对黑盒测试来衡量代码覆盖率 Squish Coco，Bullseye 等，它们的原理就是在编译的时候插入 instrumentation，中文叫插桩，在运行测试的时候用来跟踪和记录运行结果。</p>\n<p>其中我比较深入的了解过 <a href=\"https://shenxianpeng.github.io/2019/05/squishcoco/\">Squish Coco</a> 它如何使用，但对于大型项目，引入这类工具都或多或少的需要解决编译上的问题。也正是因为有一些编译问题没有解决，就一直没有购买这款价格不菲的工具 License。</p>\n<p>当我再次重新调查代码覆盖率的时候，我很惭愧的发现原来正在使用的 GCC 其实有内置的代码覆盖率的工具的，叫 <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Gcov.html\">Gcov</a></p>\n<h2 id=\"前提条件\"><a href=\"#前提条件\" class=\"headerlink\" title=\"前提条件\"></a>前提条件</h2><p>对于想使用 Gcov 的人，为了说明它是如何工作的，我准备了一段示例程序，运行这个程序之前需要先安装 <a href=\"https://gcc.gnu.org/install/index.html\">GCC</a> 和 <a href=\"http://ltp.sourceforge.net/coverage/lcov.php\">LCOV</a>。</p>\n<p>如果没有环境或不想安装，可以直接查看示例仓库的 GitHub 仓库：<a href=\"https://github.com/shenxianpeng/gcov-example\">https://github.com/shenxianpeng/gcov-example</a></p>\n<p>注：主分支 <code>master</code> 下面放的是源码，分支 <code>coverage</code> 下的 <code>out</code> 目录是最终的结果报告。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是我的测试环境上的 GCC 和 lcov 的版本</span></span><br><span class=\"line\">sh-4.2$ gcc --version</span><br><span class=\"line\">gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)</span><br><span class=\"line\">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class=\"line\">This is free software; see the <span class=\"built_in\">source</span> <span class=\"keyword\">for</span> copying conditions.  There is NO</span><br><span class=\"line\">warranty; not even <span class=\"keyword\">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class=\"line\"></span><br><span class=\"line\">sh-4.2$ lcov -v</span><br><span class=\"line\">lcov: LCOV version 1.14</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Gcov-是如何工作的\"><a href=\"#Gcov-是如何工作的\" class=\"headerlink\" title=\"Gcov 是如何工作的\"></a>Gcov 是如何工作的</h2><p>Gcov 工作流程图</p>\n<p><img src=\"/2021/08/gcov-example-cn/gcov-flow.jpg\" alt=\"flow\"></p>\n<p>主要分三步：</p>\n<ol>\n<li>在 GCC 编译的时加入特殊的编译选项，生成可执行文件，和 <code>*.gcno</code>；</li>\n<li>运行（测试）生成的可执行文件，生成了 <code>*.gcda</code> 数据文件；</li>\n<li>有了 <code>*.gcno</code> 和 <code>*.gcda</code>，通过源码生成 <code>gcov</code> 文件，最后生成代码覆盖率报告。</li>\n</ol>\n<p>下面就开始介绍其中每一步具体是怎么做的。</p>\n<h3 id=\"1-编译\"><a href=\"#1-编译\" class=\"headerlink\" title=\"1. 编译\"></a>1. 编译</h3><p>第一步编译，这里已经将编译用到的参数和文件都写在了 <code>makefile</code> 里了，只要执行 <code>make</code> 就可以编译了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>点击查看 make 命令的输出</summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror main.c</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror foo.c</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -o main main.o foo.o</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>通过输出可以看到，这个程序在编译的时候添加了两个编译选项 <code>-fprofile-arcs</code> and <code>-ftest-coverage</code>。在编译成功后，不仅生成了 <code>main</code> and <code>.o</code> 文件，同时还生成了两个 <code>.gcno</code> 文件.</p>\n<blockquote>\n<p><code>.gcno</code> 记录文件是在加入 GCC 编译选项 <code>-ftest-coverage</code> 后生成的，在编译过程中它包含用于重建基本块图和为块分配源行号的信息。</p>\n</blockquote>\n<h3 id=\"2-运行可执行文件\"><a href=\"#2-运行可执行文件\" class=\"headerlink\" title=\"2. 运行可执行文件\"></a>2. 运行可执行文件</h3><p>在编译完成后，生成了 <code>main</code> 这个可执行文件，运行（测试）它：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./main</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>点击查看运行 main 时输出</summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ ./main</span><br><span class=\"line\">Start calling foo() ...</span><br><span class=\"line\">when num is equal to 1...</span><br><span class=\"line\">when num is equal to 2...</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>当运行 <code>main</code> 后，执行结果被记录在了 <code>.gcda</code> 这个数据文件里，查看当前目录下可以看到一共有生成了两个 <code>.gcda</code> 文件，每个源文件都对应一个  <code>.gcda</code> 文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span></span><br><span class=\"line\">foo.c  foo.gcda  foo.gcno  foo.h  foo.o  img  main  main.c  main.gcda  main.gcno  main.o  makefile  README.md</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>.gcda</code> 记录数据文件的生成是因为程序在编译的时候引入了 <code>-fprofile-arcs</code> 选项。它包含弧过渡计数、值分布计数和一些摘要信息。</p>\n</blockquote>\n<h3 id=\"3-生成报告\"><a href=\"#3-生成报告\" class=\"headerlink\" title=\"3. 生成报告\"></a>3. 生成报告</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make report</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary> 点击查看生成报告的输出 </summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make report</span><br><span class=\"line\">gcov main.c foo.c</span><br><span class=\"line\">File <span class=\"string\">&#x27;main.c&#x27;</span></span><br><span class=\"line\">Lines executed:100.00% of 5</span><br><span class=\"line\">Creating <span class=\"string\">&#x27;main.c.gcov&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">File <span class=\"string\">&#x27;foo.c&#x27;</span></span><br><span class=\"line\">Lines executed:85.71% of 7</span><br><span class=\"line\">Creating <span class=\"string\">&#x27;foo.c.gcov&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Lines executed:91.67% of 12</span><br><span class=\"line\">lcov --capture --directory . --output-file coverage.info</span><br><span class=\"line\">Capturing coverage data from .</span><br><span class=\"line\">Found gcov version: 4.8.5</span><br><span class=\"line\">Scanning . <span class=\"keyword\">for</span> .gcda files ...</span><br><span class=\"line\">Found 2 data files <span class=\"keyword\">in</span> .</span><br><span class=\"line\">Processing foo.gcda</span><br><span class=\"line\">geninfo: WARNING: cannot find an entry <span class=\"keyword\">for</span> main.c.gcov <span class=\"keyword\">in</span> .gcno file, skipping file!</span><br><span class=\"line\">Processing main.gcda</span><br><span class=\"line\">Finished .info-file creation</span><br><span class=\"line\">genhtml coverage.info --output-directory out</span><br><span class=\"line\">Reading data file coverage.info</span><br><span class=\"line\">Found 2 entries.</span><br><span class=\"line\">Found common filename prefix <span class=\"string\">&quot;/workspace/coco&quot;</span></span><br><span class=\"line\">Writing .css and .png files.</span><br><span class=\"line\">Generating output.</span><br><span class=\"line\">Processing file gcov-example/main.c</span><br><span class=\"line\">Processing file gcov-example/foo.c</span><br><span class=\"line\">Writing directory view page.</span><br><span class=\"line\">Overall coverage rate:</span><br><span class=\"line\">  lines......: 91.7% (11 of 12 lines)</span><br><span class=\"line\">  <span class=\"built_in\">functions</span>..: 100.0% (2 of 2 <span class=\"built_in\">functions</span>)</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>执行 <code>make report</code> 来生成 HTML 报告，这条命令的背后实际上主要执行了以下两个步骤：</p>\n<ol>\n<li><p>在有了编译和运行时候生成的 <code>.gcno</code> 和 <code>.gcda</code> 文件后，执行命令 <code>gcov main.c foo.c</code> 即可生成 <code>.gcov</code> 代码覆盖率文件。</p>\n</li>\n<li><p>有了代码覆盖率 <code>.gcov</code> 文件，通过 <a href=\"http://ltp.sourceforge.net/coverage/lcov.php\">LCOV</a> 生成可视化代码覆盖率报告。</p>\n</li>\n</ol>\n<p>生成 HTML 结果报告的步骤如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 生成 coverage.info 数据文件</span></span><br><span class=\"line\">lcov --capture --directory . --output-file coverage.info</span><br><span class=\"line\"><span class=\"comment\"># 2. 根据这个数据文件生成报告</span></span><br><span class=\"line\">genhtml coverage.info --output-directory out</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除所有生成的文件\"><a href=\"#删除所有生成的文件\" class=\"headerlink\" title=\"删除所有生成的文件\"></a>删除所有生成的文件</h3><p>上传过程中所有生成的文件可通过执行 <code>make clean</code> 命令来彻底删除掉。</p>\n<details>\n<summary> 点击查看 make clean 命令的输出 </summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make clean</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf main *.o *.so *.gcno *.gcda *.gcov coverage.info out</span><br></pre></td></tr></table></figure>\n</details>\n\n<h2 id=\"代码覆盖率报告\"><a href=\"#代码覆盖率报告\" class=\"headerlink\" title=\"代码覆盖率报告\"></a>代码覆盖率报告</h2><p><img src=\"/2021/08/gcov-example-cn/index.png\" alt=\"index\"></p>\n<p>首页以目录结构显示</p>\n<p><img src=\"/2021/08/gcov-example-cn/example.png\" alt=\"example\"></p>\n<p>进入目录后，显示该目录下的源文件</p>\n<p><img src=\"/2021/08/gcov-example-cn/main.c.png\" alt=\"main.c\"></p>\n<p>蓝色表示这些语句被覆盖</p>\n<p><img src=\"/2021/08/gcov-example-cn/foo.c.png\" alt=\"foo.c\"></p>\n<p>红色表示没有被覆盖的语句</p>\n<blockquote>\n<p>LCOV 支持语句、函数和分支覆盖度量。</p>\n</blockquote>\n<p>旁注：</p>\n<ul>\n<li>还有另外一个生成 HTML 报告的工具叫 <a href=\"https://github.com/gcovr/gcovr\">gcovr</a>，使用 Python 开发的，它的报告在显示方式上与 LCOV 略有不同。比如 LCOV 以目录结构显示， gcovr 以文件路径来显示，前者与代码结构一直因此我更倾向于使用前者。</li>\n</ul>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><ul>\n<li>关于代码覆盖率(About Code Coverage)：<a href=\"https://shenxianpeng.github.io/2021/07/code-coverage/\">https://shenxianpeng.github.io/2021/07/code-coverage/</a></li>\n<li>在 Linux 内核中使用 Gcov 的示例：<a href=\"https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gcov.html\">https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gcov.html</a></li>\n<li>当构建环境与测试环境不同时设置环境变量：<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Cross-profiling.html#Cross-profiling\">https://gcc.gnu.org/onlinedocs/gcc/Cross-profiling.html#Cross-profiling</a></li>\n</ul>\n","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>不知道你没有遇到过和我一样的问题：几十年前的 C&#x2F;C++ 项目没有单元测试，只有回归测试，但是想知道回归测试测了哪些代码？还有哪些代码没测到？代码覆盖率是多少？今后哪些地方需要提高自动化测试用例？</p>\n<p>可能对于接触过 Java 的 Junit 和 JaCoCo 的人来说，没有单元测试应该测不了代码覆盖率吧 … 其实不然，如果不行就没有下文了 :)</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>市场上有一些工具可以针对黑盒测试来衡量代码覆盖率 Squish Coco，Bullseye 等，它们的原理就是在编译的时候插入 instrumentation，中文叫插桩，在运行测试的时候用来跟踪和记录运行结果。</p>\n<p>其中我比较深入的了解过 <a href=\"https://shenxianpeng.github.io/2019/05/squishcoco/\">Squish Coco</a> 它如何使用，但对于大型项目，引入这类工具都或多或少的需要解决编译上的问题。也正是因为有一些编译问题没有解决，就一直没有购买这款价格不菲的工具 License。</p>\n<p>当我再次重新调查代码覆盖率的时候，我很惭愧的发现原来正在使用的 GCC 其实有内置的代码覆盖率的工具的，叫 <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Gcov.html\">Gcov</a></p>\n<h2 id=\"前提条件\"><a href=\"#前提条件\" class=\"headerlink\" title=\"前提条件\"></a>前提条件</h2><p>对于想使用 Gcov 的人，为了说明它是如何工作的，我准备了一段示例程序，运行这个程序之前需要先安装 <a href=\"https://gcc.gnu.org/install/index.html\">GCC</a> 和 <a href=\"http://ltp.sourceforge.net/coverage/lcov.php\">LCOV</a>。</p>\n<p>如果没有环境或不想安装，可以直接查看示例仓库的 GitHub 仓库：<a href=\"https://github.com/shenxianpeng/gcov-example\">https://github.com/shenxianpeng/gcov-example</a></p>\n<p>注：主分支 <code>master</code> 下面放的是源码，分支 <code>coverage</code> 下的 <code>out</code> 目录是最终的结果报告。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这是我的测试环境上的 GCC 和 lcov 的版本</span></span><br><span class=\"line\">sh-4.2$ gcc --version</span><br><span class=\"line\">gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)</span><br><span class=\"line\">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class=\"line\">This is free software; see the <span class=\"built_in\">source</span> <span class=\"keyword\">for</span> copying conditions.  There is NO</span><br><span class=\"line\">warranty; not even <span class=\"keyword\">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class=\"line\"></span><br><span class=\"line\">sh-4.2$ lcov -v</span><br><span class=\"line\">lcov: LCOV version 1.14</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Gcov-是如何工作的\"><a href=\"#Gcov-是如何工作的\" class=\"headerlink\" title=\"Gcov 是如何工作的\"></a>Gcov 是如何工作的</h2><p>Gcov 工作流程图</p>\n<p><img src=\"/2021/08/gcov-example-cn/gcov-flow.jpg\" alt=\"flow\"></p>\n<p>主要分三步：</p>\n<ol>\n<li>在 GCC 编译的时加入特殊的编译选项，生成可执行文件，和 <code>*.gcno</code>；</li>\n<li>运行（测试）生成的可执行文件，生成了 <code>*.gcda</code> 数据文件；</li>\n<li>有了 <code>*.gcno</code> 和 <code>*.gcda</code>，通过源码生成 <code>gcov</code> 文件，最后生成代码覆盖率报告。</li>\n</ol>\n<p>下面就开始介绍其中每一步具体是怎么做的。</p>\n<h3 id=\"1-编译\"><a href=\"#1-编译\" class=\"headerlink\" title=\"1. 编译\"></a>1. 编译</h3><p>第一步编译，这里已经将编译用到的参数和文件都写在了 <code>makefile</code> 里了，只要执行 <code>make</code> 就可以编译了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>点击查看 make 命令的输出</summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror main.c</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -c -Wall -Werror foo.c</span><br><span class=\"line\">gcc -fPIC -fprofile-arcs -ftest-coverage -o main main.o foo.o</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>通过输出可以看到，这个程序在编译的时候添加了两个编译选项 <code>-fprofile-arcs</code> and <code>-ftest-coverage</code>。在编译成功后，不仅生成了 <code>main</code> and <code>.o</code> 文件，同时还生成了两个 <code>.gcno</code> 文件.</p>\n<blockquote>\n<p><code>.gcno</code> 记录文件是在加入 GCC 编译选项 <code>-ftest-coverage</code> 后生成的，在编译过程中它包含用于重建基本块图和为块分配源行号的信息。</p>\n</blockquote>\n<h3 id=\"2-运行可执行文件\"><a href=\"#2-运行可执行文件\" class=\"headerlink\" title=\"2. 运行可执行文件\"></a>2. 运行可执行文件</h3><p>在编译完成后，生成了 <code>main</code> 这个可执行文件，运行（测试）它：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./main</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary>点击查看运行 main 时输出</summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ ./main</span><br><span class=\"line\">Start calling foo() ...</span><br><span class=\"line\">when num is equal to 1...</span><br><span class=\"line\">when num is equal to 2...</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>当运行 <code>main</code> 后，执行结果被记录在了 <code>.gcda</code> 这个数据文件里，查看当前目录下可以看到一共有生成了两个 <code>.gcda</code> 文件，每个源文件都对应一个  <code>.gcda</code> 文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span></span><br><span class=\"line\">foo.c  foo.gcda  foo.gcno  foo.h  foo.o  img  main  main.c  main.gcda  main.gcno  main.o  makefile  README.md</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>.gcda</code> 记录数据文件的生成是因为程序在编译的时候引入了 <code>-fprofile-arcs</code> 选项。它包含弧过渡计数、值分布计数和一些摘要信息。</p>\n</blockquote>\n<h3 id=\"3-生成报告\"><a href=\"#3-生成报告\" class=\"headerlink\" title=\"3. 生成报告\"></a>3. 生成报告</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make report</span><br></pre></td></tr></table></figure>\n\n<details>\n<summary> 点击查看生成报告的输出 </summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make report</span><br><span class=\"line\">gcov main.c foo.c</span><br><span class=\"line\">File <span class=\"string\">&#x27;main.c&#x27;</span></span><br><span class=\"line\">Lines executed:100.00% of 5</span><br><span class=\"line\">Creating <span class=\"string\">&#x27;main.c.gcov&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">File <span class=\"string\">&#x27;foo.c&#x27;</span></span><br><span class=\"line\">Lines executed:85.71% of 7</span><br><span class=\"line\">Creating <span class=\"string\">&#x27;foo.c.gcov&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Lines executed:91.67% of 12</span><br><span class=\"line\">lcov --capture --directory . --output-file coverage.info</span><br><span class=\"line\">Capturing coverage data from .</span><br><span class=\"line\">Found gcov version: 4.8.5</span><br><span class=\"line\">Scanning . <span class=\"keyword\">for</span> .gcda files ...</span><br><span class=\"line\">Found 2 data files <span class=\"keyword\">in</span> .</span><br><span class=\"line\">Processing foo.gcda</span><br><span class=\"line\">geninfo: WARNING: cannot find an entry <span class=\"keyword\">for</span> main.c.gcov <span class=\"keyword\">in</span> .gcno file, skipping file!</span><br><span class=\"line\">Processing main.gcda</span><br><span class=\"line\">Finished .info-file creation</span><br><span class=\"line\">genhtml coverage.info --output-directory out</span><br><span class=\"line\">Reading data file coverage.info</span><br><span class=\"line\">Found 2 entries.</span><br><span class=\"line\">Found common filename prefix <span class=\"string\">&quot;/workspace/coco&quot;</span></span><br><span class=\"line\">Writing .css and .png files.</span><br><span class=\"line\">Generating output.</span><br><span class=\"line\">Processing file gcov-example/main.c</span><br><span class=\"line\">Processing file gcov-example/foo.c</span><br><span class=\"line\">Writing directory view page.</span><br><span class=\"line\">Overall coverage rate:</span><br><span class=\"line\">  lines......: 91.7% (11 of 12 lines)</span><br><span class=\"line\">  <span class=\"built_in\">functions</span>..: 100.0% (2 of 2 <span class=\"built_in\">functions</span>)</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>执行 <code>make report</code> 来生成 HTML 报告，这条命令的背后实际上主要执行了以下两个步骤：</p>\n<ol>\n<li><p>在有了编译和运行时候生成的 <code>.gcno</code> 和 <code>.gcda</code> 文件后，执行命令 <code>gcov main.c foo.c</code> 即可生成 <code>.gcov</code> 代码覆盖率文件。</p>\n</li>\n<li><p>有了代码覆盖率 <code>.gcov</code> 文件，通过 <a href=\"http://ltp.sourceforge.net/coverage/lcov.php\">LCOV</a> 生成可视化代码覆盖率报告。</p>\n</li>\n</ol>\n<p>生成 HTML 结果报告的步骤如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 生成 coverage.info 数据文件</span></span><br><span class=\"line\">lcov --capture --directory . --output-file coverage.info</span><br><span class=\"line\"><span class=\"comment\"># 2. 根据这个数据文件生成报告</span></span><br><span class=\"line\">genhtml coverage.info --output-directory out</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除所有生成的文件\"><a href=\"#删除所有生成的文件\" class=\"headerlink\" title=\"删除所有生成的文件\"></a>删除所有生成的文件</h3><p>上传过程中所有生成的文件可通过执行 <code>make clean</code> 命令来彻底删除掉。</p>\n<details>\n<summary> 点击查看 make clean 命令的输出 </summary>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh-4.2$ make clean</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf main *.o *.so *.gcno *.gcda *.gcov coverage.info out</span><br></pre></td></tr></table></figure>\n</details>\n\n<h2 id=\"代码覆盖率报告\"><a href=\"#代码覆盖率报告\" class=\"headerlink\" title=\"代码覆盖率报告\"></a>代码覆盖率报告</h2><p><img src=\"/2021/08/gcov-example-cn/index.png\" alt=\"index\"></p>\n<p>首页以目录结构显示</p>\n<p><img src=\"/2021/08/gcov-example-cn/example.png\" alt=\"example\"></p>\n<p>进入目录后，显示该目录下的源文件</p>\n<p><img src=\"/2021/08/gcov-example-cn/main.c.png\" alt=\"main.c\"></p>\n<p>蓝色表示这些语句被覆盖</p>\n<p><img src=\"/2021/08/gcov-example-cn/foo.c.png\" alt=\"foo.c\"></p>\n<p>红色表示没有被覆盖的语句</p>\n<blockquote>\n<p>LCOV 支持语句、函数和分支覆盖度量。</p>\n</blockquote>\n<p>旁注：</p>\n<ul>\n<li>还有另外一个生成 HTML 报告的工具叫 <a href=\"https://github.com/gcovr/gcovr\">gcovr</a>，使用 Python 开发的，它的报告在显示方式上与 LCOV 略有不同。比如 LCOV 以目录结构显示， gcovr 以文件路径来显示，前者与代码结构一直因此我更倾向于使用前者。</li>\n</ul>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><ul>\n<li>关于代码覆盖率(About Code Coverage)：<a href=\"https://shenxianpeng.github.io/2021/07/code-coverage/\">https://shenxianpeng.github.io/2021/07/code-coverage/</a></li>\n<li>在 Linux 内核中使用 Gcov 的示例：<a href=\"https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gcov.html\">https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gcov.html</a></li>\n<li>当构建环境与测试环境不同时设置环境变量：<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Cross-profiling.html#Cross-profiling\">https://gcc.gnu.org/onlinedocs/gcc/Cross-profiling.html#Cross-profiling</a></li>\n</ul>","categories":[{"name":"Coverage","path":"api/categories/Coverage.json"}],"tags":[{"name":"Coverage","path":"api/tags/Coverage.json"},{"name":"Gcov","path":"api/tags/Gcov.json"},{"name":"LCOV","path":"api/tags/LCOV.json"}]}