{"title":"提升代码可追溯性：一招把 PR 描述写入 Git commit","slug":"2025/06/commit-message-template","date":"2025-06-12T04:32:00.000Z","updated":"2025-08-03T19:21:27.167Z","comments":true,"path":"api/articles/2025/06/commit-message-template.json","excerpt":"背景最近和同事讨论了一个看似简单但很重要的问题：我们如何确保 PR 中有价值的信息不会随着时间和工具的更替而丢失？虽然我们日常使用 Bitbucket 来协作开发，但未来也许会迁移到 GitHub、GitLab 等平台。这些托管平台可能会变，但 Git 本身作为代码历史的记录核心，很可能还会长期存在。问题也就来了：PR 页面里描述的变更背景、解决思路和关键讨论，如果只保存在 PR 工具里，就很可能在平台迁移后“消失”。而这些信息，本应是 commit message 的一部分。我们讨论过的一些方案：在 git commit -m 时手动记录问题的解决方式 —— 但容易被忽略或写得不完整。模仿 pip 项目使用 NEWS 文件 来记录每次变更 —— 虽然能保留信息，但这种方式更适合用于生成 release note，而不是记录修改的动机或原因。强制要求成员把内容写在 Jira ticket 中 —— 工具间割裂，不利于在代码上下文中快速理解历史。最终我们决定：使用 Bitbucket 的 Commit Message Templates 功能，把 PR 的描述直接写入 Git commit 中。","covers":["/2025/06/commit-message-template/bb-template.png","/2025/06/commit-message-template/bb-result.png"],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近和同事讨论了一个看似简单但很重要的问题：</p>\n<p><strong>我们如何确保 PR 中有价值的信息不会随着时间和工具的更替而丢失？</strong></p>\n<p>虽然我们日常使用 Bitbucket 来协作开发，但未来也许会迁移到 GitHub、GitLab 等平台。<strong>这些托管平台可能会变，但 Git 本身作为代码历史的记录核心，很可能还会长期存在。</strong></p>\n<p>问题也就来了：</p>\n<blockquote>\n<p>PR 页面里描述的变更背景、解决思路和关键讨论，如果只保存在 PR 工具里，就很可能在平台迁移后“消失”。而这些信息，本应是 commit message 的一部分。</p>\n</blockquote>\n<h2 id=\"我们讨论过的一些方案：\"><a href=\"#我们讨论过的一些方案：\" class=\"headerlink\" title=\"我们讨论过的一些方案：\"></a>我们讨论过的一些方案：</h2><ol>\n<li><strong>在 <code>git commit -m</code> 时手动记录问题的解决方式</strong> —— 但容易被忽略或写得不完整。</li>\n<li><strong>模仿 pip 项目使用 <code>NEWS</code> 文件</strong> 来记录每次变更 —— 虽然能保留信息，但这种方式更适合用于生成 release note，而不是记录修改的动机或原因。</li>\n<li><strong>强制要求成员把内容写在 Jira ticket 中</strong> —— 工具间割裂，不利于在代码上下文中快速理解历史。</li>\n</ol>\n<p>最终我们决定：<strong>使用 Bitbucket 的 Commit Message Templates 功能，把 PR 的描述直接写入 Git commit 中。</strong></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Bitbucket-的-Commit-Message-Templates-功能\"><a href=\"#Bitbucket-的-Commit-Message-Templates-功能\" class=\"headerlink\" title=\"Bitbucket 的 Commit Message Templates 功能\"></a>Bitbucket 的 Commit Message Templates 功能</h2><p>Bitbucket 支持在合并 PR 时自动生成 commit message，并允许通过模板插入有用的信息。文档地址如下：<br>🔗 <a href=\"https://confluence.atlassian.com/bitbucketserver0819/pull-request-merge-strategies-1416826109.html\">Pull request merge strategies - Bitbucket Server</a></p>\n<blockquote>\n<p>我看到了 GitLab 也有类似的功能，但 GitHub 似乎没有。</p>\n<p>参考 <a href=\"https://docs.gitlab.com/user/project/merge_requests/commit_templates/\">GitLab Commit Templates 官方文档</a></p>\n</blockquote>\n<p>你可以在模板中使用以下变量：</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>title</code></td>\n<td>PR 标题</td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>PR ID</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>PR 描述</td>\n</tr>\n<tr>\n<td><code>approvers</code></td>\n<td>当前已批准的审阅人</td>\n</tr>\n<tr>\n<td><code>fromRefName</code> &#x2F; <code>toRefName</code></td>\n<td>源 &#x2F; 目标分支名称</td>\n</tr>\n<tr>\n<td><code>fromProjectKey</code> &#x2F; <code>toProjectKey</code></td>\n<td>源 &#x2F; 目标项目</td>\n</tr>\n<tr>\n<td><code>fromRepoSlug</code> &#x2F; <code>toRepoSlug</code></td>\n<td>源 &#x2F; 目标仓库</td>\n</tr>\n<tr>\n<td><code>crossRepoPullRequestRepo</code></td>\n<td>跨仓库 PR 的源仓库信息</td>\n</tr>\n</tbody></table>\n<h2 id=\"我们是怎么用的？\"><a href=\"#我们是怎么用的？\" class=\"headerlink\" title=\"我们是怎么用的？\"></a>我们是怎么用的？</h2><p>在 Bitbucket 的仓库设置中，你可以配置 PR 的合并提交模板，找到设置：</p>\n<p>Repository settings -&gt; Merge strategies -&gt; Commit message template</p>\n<p>配置后，当你在 PR 页面合并时，Bitbucket 会自动把 PR 的标题、描述、相关 ID 等内容写入最终的 merge commit message 中。</p>\n<p>这样，不管将来团队是否继续使用 Bitbucket，<strong>PR 的关键信息都将永远保存在 Git 历史中</strong>。</p>\n<p>下面是实际效果：</p>\n<p>📥 配置模板界面：<br><img src=\"/2025/06/commit-message-template/bb-template.png\" alt=\"Bitbucket 模板配置界面\"></p>\n<p>📤 最终生成的 Git commit message：<br><img src=\"/2025/06/commit-message-template/bb-result.png\" alt=\"最终合并 commit 的样子\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这项改动虽然小，却帮助我们从流程上保护了代码变更的上下文。它让 PR 不再是“临时信息容器”，而是自然地成为 Git 历史的一部分。</p>\n<p>如果你也在使用 Bitbucket，不妨试试这个功能。</p>\n<p>让 Git commit message，不只是代码提交，更是决策和演进的记录。</p>\n<hr>\n<p>转载本站文章请注明作者和出处，请勿用于任何商业用途。欢迎关注公众号「DevOps攻城狮」</p>\n","more":"<h2 id=\"Bitbucket-的-Commit-Message-Templates-功能\"><a href=\"#Bitbucket-的-Commit-Message-Templates-功能\" class=\"headerlink\" title=\"Bitbucket 的 Commit Message Templates 功能\"></a>Bitbucket 的 Commit Message Templates 功能</h2><p>Bitbucket 支持在合并 PR 时自动生成 commit message，并允许通过模板插入有用的信息。文档地址如下：<br>🔗 <a href=\"https://confluence.atlassian.com/bitbucketserver0819/pull-request-merge-strategies-1416826109.html\">Pull request merge strategies - Bitbucket Server</a></p>\n<blockquote>\n<p>我看到了 GitLab 也有类似的功能，但 GitHub 似乎没有。</p>\n<p>参考 <a href=\"https://docs.gitlab.com/user/project/merge_requests/commit_templates/\">GitLab Commit Templates 官方文档</a></p>\n</blockquote>\n<p>你可以在模板中使用以下变量：</p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>title</code></td>\n<td>PR 标题</td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>PR ID</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>PR 描述</td>\n</tr>\n<tr>\n<td><code>approvers</code></td>\n<td>当前已批准的审阅人</td>\n</tr>\n<tr>\n<td><code>fromRefName</code> &#x2F; <code>toRefName</code></td>\n<td>源 &#x2F; 目标分支名称</td>\n</tr>\n<tr>\n<td><code>fromProjectKey</code> &#x2F; <code>toProjectKey</code></td>\n<td>源 &#x2F; 目标项目</td>\n</tr>\n<tr>\n<td><code>fromRepoSlug</code> &#x2F; <code>toRepoSlug</code></td>\n<td>源 &#x2F; 目标仓库</td>\n</tr>\n<tr>\n<td><code>crossRepoPullRequestRepo</code></td>\n<td>跨仓库 PR 的源仓库信息</td>\n</tr>\n</tbody></table>\n<h2 id=\"我们是怎么用的？\"><a href=\"#我们是怎么用的？\" class=\"headerlink\" title=\"我们是怎么用的？\"></a>我们是怎么用的？</h2><p>在 Bitbucket 的仓库设置中，你可以配置 PR 的合并提交模板，找到设置：</p>\n<p>Repository settings -&gt; Merge strategies -&gt; Commit message template</p>\n<p>配置后，当你在 PR 页面合并时，Bitbucket 会自动把 PR 的标题、描述、相关 ID 等内容写入最终的 merge commit message 中。</p>\n<p>这样，不管将来团队是否继续使用 Bitbucket，<strong>PR 的关键信息都将永远保存在 Git 历史中</strong>。</p>\n<p>下面是实际效果：</p>\n<p>📥 配置模板界面：<br><img src=\"/2025/06/commit-message-template/bb-template.png\" alt=\"Bitbucket 模板配置界面\"></p>\n<p>📤 最终生成的 Git commit message：<br><img src=\"/2025/06/commit-message-template/bb-result.png\" alt=\"最终合并 commit 的样子\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这项改动虽然小，却帮助我们从流程上保护了代码变更的上下文。它让 PR 不再是“临时信息容器”，而是自然地成为 Git 历史的一部分。</p>\n<p>如果你也在使用 Bitbucket，不妨试试这个功能。</p>\n<p>让 Git commit message，不只是代码提交，更是决策和演进的记录。</p>\n<hr>\n<p>转载本站文章请注明作者和出处，请勿用于任何商业用途。欢迎关注公众号「DevOps攻城狮」</p>","categories":[{"name":"Git","path":"api/categories/Git.json"}],"tags":[{"name":"Git","path":"api/tags/Git.json"},{"name":"Bitbucket","path":"api/tags/Bitbucket.json"}]}