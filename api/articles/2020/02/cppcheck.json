{"title":"一款免费的 C/C++ 静态代码分析工具 Cppcheck 与 Jenkins 集成","slug":"2020/02/cppcheck","date":"2020-02-16T13:14:12.000Z","updated":"2023-12-29T15:31:28.105Z","comments":true,"path":"api/articles/2020/02/cppcheck.json","excerpt":"由于历史遗留原因，我们当前产品的代码仓库里遗留很多 Warning，这些 Warning 不是一时半会可以解决掉的。只有通过不断的丰富自动化测试用例，来保障最后的质量关卡，才敢有条不紊的进行 Warining 的修复，在次之前，如何有效杜绝继续引入更多的 Warining 是当下应该做的。","covers":["/2020/02/cppcheck/cppcheck-icon.png","/2020/02/cppcheck/cppcheck-view.png","/2020/02/cppcheck/cppcheck-code.png"],"content":"<p>由于历史遗留原因，我们当前产品的代码仓库里遗留很多 Warning，这些 Warning 不是一时半会可以解决掉的。只有通过不断的丰富自动化测试用例，来保障最后的质量关卡，才敢有条不紊的进行 Warining 的修复，在次之前，如何有效杜绝继续引入更多的 Warining 是当下应该做的。</p>\n<span id=\"more\"></span>\n\n<p>因此我想在 Pull Request 阶段加入 C&#x2F;C++ 的静态代码扫描的集成，但是很多工具只要涉及的是 C&#x2F;C++ 经常都是收费的，比如这里首选的 SonarQube，Community 版本不支持 C&#x2F;C++ 代码扫描，只有 Developer 以及 Enterprise 等付费版本才支持，在静态代码扫描还没有带来收益之前，盲目的付费只会给产品带来更多的成本，因此决定先寻找其他开源工具来替代。</p>\n<p>最终我选择了 CPPCheck，主要有以下几个原因：</p>\n<ol>\n<li>这是为数不多的 C&#x2F;C++ 开源静态代码扫描工具</li>\n<li>可以与 Jenkins 集成，可以在 Jenkins 里查看结果报告</li>\n<li>支持 Jenkins Pipeline</li>\n</ol>\n<p>本文记录我调查和使用的经验，如果您也相关的需求，提供一点参考。</p>\n<h2 id=\"安装-Cppcheck\"><a href=\"#安装-Cppcheck\" class=\"headerlink\" title=\"安装 Cppcheck\"></a>安装 Cppcheck</h2><p>安装到 Linux</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install cppcheck.x86_64</span><br></pre></td></tr></table></figure>\n\n<p>其他平台安装请参考 cppcheck <a href=\"http://cppcheck.sourceforge.net/\">官网</a></p>\n<p>如果你在 Linux 无法通过命令一键安装，也可通过下载源代码构建 cppcheck。以下是从代码手动构建一个 cppcheck 可执行文件的步骤</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> opt &amp;&amp; <span class=\"built_in\">mkdir</span> cppcheck &amp;&amp; <span class=\"built_in\">cd</span> cppcheck</span><br><span class=\"line\"><span class=\"comment\"># 下载代码</span></span><br><span class=\"line\">wget https://github.com/danmar/cppcheck/archive/1.90.tar.gz</span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">tar -xvf 1.90.tar.gz</span><br><span class=\"line\"><span class=\"comment\"># make build</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> cppcheck-1.90</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\">cmake ..</span><br><span class=\"line\">cmake --build .</span><br><span class=\"line\"><span class=\"comment\"># link</span></span><br><span class=\"line\">sudo <span class=\"built_in\">ln</span> -s /opt/cppcheck/cppcheck-1.90/cppcheck /usr/bin/cppcheck</span><br><span class=\"line\"><span class=\"comment\"># 检查是否安装成功</span></span><br><span class=\"line\"><span class=\"built_in\">which</span> cppcheck</span><br><span class=\"line\">/usr/bin/cppcheck</span><br><span class=\"line\">cppcheck --version</span><br><span class=\"line\">Cppcheck 1.90</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-cppcheck-静态代码扫描\"><a href=\"#使用-cppcheck-静态代码扫描\" class=\"headerlink\" title=\"使用 cppcheck 静态代码扫描\"></a>使用 cppcheck 静态代码扫描</h2><p>在与 Jenkins 集成之前，先看看这个工具怎么用。通过查阅<a href=\"http://cppcheck.sourceforge.net/manual.pdf\">Cppcheck 官方文档</a>，一般的使用如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例如扫描 src 下 public 和 themes 两个目录下的代码将结果输出到 cppcheck.xml</span></span><br><span class=\"line\">cppcheck src/public src/themes --xml 2&gt; cppcheck.xml</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cppcheck-与-Jenkins-集成\"><a href=\"#Cppcheck-与-Jenkins-集成\" class=\"headerlink\" title=\"Cppcheck 与 Jenkins 集成\"></a>Cppcheck 与 Jenkins 集成</h2><p>首先，下载 Cppcheck Jenkins <a href=\"https://plugins.jenkins.io/cppcheck/\">插件</a>，通过 Pipeline Syntax 生成了此代码 <code>publishCppcheck pattern: &#39;cppcheck.xml&#39;</code></p>\n<p>但是在读取 xml 文件进行报告展示时，我遇到了两个问题：</p>\n<p>问题1：分析 cppcheck.xml 我在有的 Linux 机器上成功，有的机器上会失败，我怀疑是我的 JDK 版本不同所致。Jenkins JIRA 我也找到了次问题 <a href=\"https://issues.jenkins-ci.org/browse/JENKINS-60077\">JENKINS-60077</a> 但目前还没有人来解决。</p>\n<p>我之所以没有继续尝试去解决问题1，最主要的原因是它有一个对我来说是更致命的缺陷，那就是下面说的问题。</p>\n<p>问题2： 无法通过 Cppcheck Results 报告直接查看代码，这样就算扫描出来了问题还需要去 git 或是本地的 IDE 上去查看具体的问题，大大降低效率。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看代码文件时会出错</span></span><br><span class=\"line\">Can<span class=\"string\">&#x27;t read file: Can&#x27;</span>t access the file: file:/disk1/agent/workspace/cppcheck-ud113/src/public/dummy/err_printf.c</span><br></pre></td></tr></table></figure>\n\n<p>并且官方也相应的 Ticket 记录了该问题 <a href=\"https://issues.jenkins-ci.org/browse/JENKINS-42613\">JENKINS-42613</a> 和 <a href=\"https://issues.jenkins-ci.org/browse/JENKINS-54209\">JENKINS-54209</a>，JENKINS-42613 一直在等待 merge，截止发文，都还是暂时没有解决。</p>\n<p>最后我发现 <a href=\"https://plugins.jenkins.io/warnings-ng/\">Warnings Next Generation</a> 这个插件将取代整个 Jenkins 静态分析套件，其中包含了这些插件 Android Lint, CheckStyle, Dry, FindBugs, PMD, Warnings, Static Analysis Utilities, Static Analysis Collector，最后通过 Warnings Next Generation 插件解决了报告展示的问题。</p>\n<p>这里可以通过 Pipeline Syntax 生成读取报告代码 <code>recordIssues(tools: [codeAnalysis(pattern: &#39;cppcheck.xml&#39;)])</code></p>\n<p>更多有关 Warnings Next Generation 插件的使用，请参看<a href=\"https://github.com/jenkinsci/warnings-ng-plugin/blob/master/doc/Documentation.md\">文档</a></p>\n<h3 id=\"最终-Pipeline-示例如下\"><a href=\"#最终-Pipeline-示例如下\" class=\"headerlink\" title=\"最终 Pipeline 示例如下\"></a>最终 Pipeline 示例如下</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">  agent &#123;</span><br><span class=\"line\">    node &#123;</span><br><span class=\"line\">      label <span class=\"string\">&#x27;cppcheck&#x27;</span></span><br><span class=\"line\">      customWorkspace <span class=\"string\">&quot;/agent/workspace/cppcheck&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  parameters &#123;</span><br><span class=\"line\">    string(name: <span class=\"string\">&#x27;Branch&#x27;</span>, defaultValue: <span class=\"string\">&#x27;develop&#x27;</span>, description: <span class=\"string\">&#x27;Which branch do you want to do cppcheck?&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  options &#123;</span><br><span class=\"line\">    timestamps ()</span><br><span class=\"line\">    buildDiscarder(logRotator(numToKeepStr:<span class=\"string\">&#x27;50&#x27;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  stage(<span class=\"string\">&quot;Checkout&quot;</span>)&#123;</span><br><span class=\"line\">    steps&#123;</span><br><span class=\"line\">      checkout([<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class=\"string\">&#x27;*/$&#123;Branch&#125;&#x27;</span>]],</span><br><span class=\"line\">      browser: [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;BitbucketWeb&#x27;</span>, repoUrl: <span class=\"string\">&#x27;https://git.yourcompany.com/projects/repos/cppcheck-example/browse&#x27;</span>],</span><br><span class=\"line\">      doGenerateSubmoduleConfigurations: <span class=\"literal\">false</span>, extensions: [</span><br><span class=\"line\">      [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;LocalBranch&#x27;</span>, localBranch: <span class=\"string\">&#x27;**&#x27;</span>], [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;CheckoutOption&#x27;</span>, <span class=\"built_in\">timeout</span>: 30], [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;CloneOption&#x27;</span>, depth: 1, noTags: <span class=\"literal\">false</span>, reference: <span class=\"string\">&#x27;&#x27;</span>, shallow: <span class=\"literal\">true</span>,   <span class=\"built_in\">timeout</span>: 30]], submoduleCfg: [],</span><br><span class=\"line\">      userRemoteConfigs: [[credentialsId: <span class=\"string\">&#x27;d1cbab74-823d-41aa-abb7&#x27;</span>, url: <span class=\"string\">&#x27;https://git.yourcompany.com/scm/cppcheck-example.git&#x27;</span>]]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stage(<span class=\"string\">&quot;Cppcheck&quot;</span>)&#123;</span><br><span class=\"line\">    steps&#123;</span><br><span class=\"line\">      script &#123;</span><br><span class=\"line\">        sh <span class=\"string\">&#x27;cppcheck src/public src/themes --xml 2&gt; cppcheck.xml&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stage(<span class=\"string\">&#x27;Publish results&#x27;</span>)&#123;</span><br><span class=\"line\">    steps &#123;</span><br><span class=\"line\">      recordIssues(tools: [cppCheck(pattern: <span class=\"string\">&#x27;cppcheck.xml&#x27;</span>)])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"报告展示\"><a href=\"#报告展示\" class=\"headerlink\" title=\"报告展示\"></a>报告展示</h3><p>我将 CPPCheck 应用到每个 Pull Request 里，当开发提交新的代码时，CPPCheck 就会去扫描代码，然后跟之前的历史记录做对比。CPPCheck 执行成功并生成报告，这里会出现一个按钮，点击进入。</p>\n<p><img src=\"/2020/02/cppcheck/cppcheck-icon.png\" alt=\"CPPCheck 入口\"></p>\n<p>打开之后就会当前分支代码的扫结果。</p>\n<p><img src=\"/2020/02/cppcheck/cppcheck-view.png\" alt=\"CPPCheck 当前的结果\"></p>\n<p>CPPCheck 有三个维度来来展示静态代码扫描结果：</p>\n<ol>\n<li><p>严重程度分布（Severities Distribution）：这里分为 High，Normal，Low 三种级别</p>\n</li>\n<li><p>参考比较（Reference Comparison）：这里会参考之前的数据进行比较，如果有新增就会显示 New，如果是现存的就显示为 Outstanding，如果减少了就会显示 Fixed</p>\n</li>\n<li><p>历史（History）：随着代码的增加和修改，这里会显示一个历史记录的趋势</p>\n</li>\n</ol>\n<p>注意：cppcheck 相关的 xml 是存储在 Jenkins master 上，只有当前的 Jenkins Job 被人为删掉，那么 cppcheck xml 才会被删掉。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-sh-4.2$ <span class=\"built_in\">ls</span> -l cppcheck*</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins 418591 Feb 27 05:54 cppcheck-blames.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins    219 Feb 27 05:54 cppcheck-fixed-issues.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins 142298 Feb 27 05:54 cppcheck-forensics.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins    219 Feb 27 05:54 cppcheck-new-issues.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins 488636 Feb 27 05:54 cppcheck-outstanding-issues.xml</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2020/02/cppcheck/cppcheck-code.png\" alt=\"查看具体 Warining 代码\"></p>\n<p>点击相应的连接就可以直接跳转到具体的代码警告位置了。</p>\n<p>它是不是还挺香的？</p>\n","more":"<p>因此我想在 Pull Request 阶段加入 C&#x2F;C++ 的静态代码扫描的集成，但是很多工具只要涉及的是 C&#x2F;C++ 经常都是收费的，比如这里首选的 SonarQube，Community 版本不支持 C&#x2F;C++ 代码扫描，只有 Developer 以及 Enterprise 等付费版本才支持，在静态代码扫描还没有带来收益之前，盲目的付费只会给产品带来更多的成本，因此决定先寻找其他开源工具来替代。</p>\n<p>最终我选择了 CPPCheck，主要有以下几个原因：</p>\n<ol>\n<li>这是为数不多的 C&#x2F;C++ 开源静态代码扫描工具</li>\n<li>可以与 Jenkins 集成，可以在 Jenkins 里查看结果报告</li>\n<li>支持 Jenkins Pipeline</li>\n</ol>\n<p>本文记录我调查和使用的经验，如果您也相关的需求，提供一点参考。</p>\n<h2 id=\"安装-Cppcheck\"><a href=\"#安装-Cppcheck\" class=\"headerlink\" title=\"安装 Cppcheck\"></a>安装 Cppcheck</h2><p>安装到 Linux</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install cppcheck.x86_64</span><br></pre></td></tr></table></figure>\n\n<p>其他平台安装请参考 cppcheck <a href=\"http://cppcheck.sourceforge.net/\">官网</a></p>\n<p>如果你在 Linux 无法通过命令一键安装，也可通过下载源代码构建 cppcheck。以下是从代码手动构建一个 cppcheck 可执行文件的步骤</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> opt &amp;&amp; <span class=\"built_in\">mkdir</span> cppcheck &amp;&amp; <span class=\"built_in\">cd</span> cppcheck</span><br><span class=\"line\"><span class=\"comment\"># 下载代码</span></span><br><span class=\"line\">wget https://github.com/danmar/cppcheck/archive/1.90.tar.gz</span><br><span class=\"line\"><span class=\"comment\"># 解压</span></span><br><span class=\"line\">tar -xvf 1.90.tar.gz</span><br><span class=\"line\"><span class=\"comment\"># make build</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> cppcheck-1.90</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\">cmake ..</span><br><span class=\"line\">cmake --build .</span><br><span class=\"line\"><span class=\"comment\"># link</span></span><br><span class=\"line\">sudo <span class=\"built_in\">ln</span> -s /opt/cppcheck/cppcheck-1.90/cppcheck /usr/bin/cppcheck</span><br><span class=\"line\"><span class=\"comment\"># 检查是否安装成功</span></span><br><span class=\"line\"><span class=\"built_in\">which</span> cppcheck</span><br><span class=\"line\">/usr/bin/cppcheck</span><br><span class=\"line\">cppcheck --version</span><br><span class=\"line\">Cppcheck 1.90</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用-cppcheck-静态代码扫描\"><a href=\"#使用-cppcheck-静态代码扫描\" class=\"headerlink\" title=\"使用 cppcheck 静态代码扫描\"></a>使用 cppcheck 静态代码扫描</h2><p>在与 Jenkins 集成之前，先看看这个工具怎么用。通过查阅<a href=\"http://cppcheck.sourceforge.net/manual.pdf\">Cppcheck 官方文档</a>，一般的使用如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例如扫描 src 下 public 和 themes 两个目录下的代码将结果输出到 cppcheck.xml</span></span><br><span class=\"line\">cppcheck src/public src/themes --xml 2&gt; cppcheck.xml</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cppcheck-与-Jenkins-集成\"><a href=\"#Cppcheck-与-Jenkins-集成\" class=\"headerlink\" title=\"Cppcheck 与 Jenkins 集成\"></a>Cppcheck 与 Jenkins 集成</h2><p>首先，下载 Cppcheck Jenkins <a href=\"https://plugins.jenkins.io/cppcheck/\">插件</a>，通过 Pipeline Syntax 生成了此代码 <code>publishCppcheck pattern: &#39;cppcheck.xml&#39;</code></p>\n<p>但是在读取 xml 文件进行报告展示时，我遇到了两个问题：</p>\n<p>问题1：分析 cppcheck.xml 我在有的 Linux 机器上成功，有的机器上会失败，我怀疑是我的 JDK 版本不同所致。Jenkins JIRA 我也找到了次问题 <a href=\"https://issues.jenkins-ci.org/browse/JENKINS-60077\">JENKINS-60077</a> 但目前还没有人来解决。</p>\n<p>我之所以没有继续尝试去解决问题1，最主要的原因是它有一个对我来说是更致命的缺陷，那就是下面说的问题。</p>\n<p>问题2： 无法通过 Cppcheck Results 报告直接查看代码，这样就算扫描出来了问题还需要去 git 或是本地的 IDE 上去查看具体的问题，大大降低效率。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看代码文件时会出错</span></span><br><span class=\"line\">Can<span class=\"string\">&#x27;t read file: Can&#x27;</span>t access the file: file:/disk1/agent/workspace/cppcheck-ud113/src/public/dummy/err_printf.c</span><br></pre></td></tr></table></figure>\n\n<p>并且官方也相应的 Ticket 记录了该问题 <a href=\"https://issues.jenkins-ci.org/browse/JENKINS-42613\">JENKINS-42613</a> 和 <a href=\"https://issues.jenkins-ci.org/browse/JENKINS-54209\">JENKINS-54209</a>，JENKINS-42613 一直在等待 merge，截止发文，都还是暂时没有解决。</p>\n<p>最后我发现 <a href=\"https://plugins.jenkins.io/warnings-ng/\">Warnings Next Generation</a> 这个插件将取代整个 Jenkins 静态分析套件，其中包含了这些插件 Android Lint, CheckStyle, Dry, FindBugs, PMD, Warnings, Static Analysis Utilities, Static Analysis Collector，最后通过 Warnings Next Generation 插件解决了报告展示的问题。</p>\n<p>这里可以通过 Pipeline Syntax 生成读取报告代码 <code>recordIssues(tools: [codeAnalysis(pattern: &#39;cppcheck.xml&#39;)])</code></p>\n<p>更多有关 Warnings Next Generation 插件的使用，请参看<a href=\"https://github.com/jenkinsci/warnings-ng-plugin/blob/master/doc/Documentation.md\">文档</a></p>\n<h3 id=\"最终-Pipeline-示例如下\"><a href=\"#最终-Pipeline-示例如下\" class=\"headerlink\" title=\"最终 Pipeline 示例如下\"></a>最终 Pipeline 示例如下</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">  agent &#123;</span><br><span class=\"line\">    node &#123;</span><br><span class=\"line\">      label <span class=\"string\">&#x27;cppcheck&#x27;</span></span><br><span class=\"line\">      customWorkspace <span class=\"string\">&quot;/agent/workspace/cppcheck&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  parameters &#123;</span><br><span class=\"line\">    string(name: <span class=\"string\">&#x27;Branch&#x27;</span>, defaultValue: <span class=\"string\">&#x27;develop&#x27;</span>, description: <span class=\"string\">&#x27;Which branch do you want to do cppcheck?&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  options &#123;</span><br><span class=\"line\">    timestamps ()</span><br><span class=\"line\">    buildDiscarder(logRotator(numToKeepStr:<span class=\"string\">&#x27;50&#x27;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  stage(<span class=\"string\">&quot;Checkout&quot;</span>)&#123;</span><br><span class=\"line\">    steps&#123;</span><br><span class=\"line\">      checkout([<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class=\"string\">&#x27;*/$&#123;Branch&#125;&#x27;</span>]],</span><br><span class=\"line\">      browser: [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;BitbucketWeb&#x27;</span>, repoUrl: <span class=\"string\">&#x27;https://git.yourcompany.com/projects/repos/cppcheck-example/browse&#x27;</span>],</span><br><span class=\"line\">      doGenerateSubmoduleConfigurations: <span class=\"literal\">false</span>, extensions: [</span><br><span class=\"line\">      [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;LocalBranch&#x27;</span>, localBranch: <span class=\"string\">&#x27;**&#x27;</span>], [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;CheckoutOption&#x27;</span>, <span class=\"built_in\">timeout</span>: 30], [<span class=\"variable\">$class</span>: <span class=\"string\">&#x27;CloneOption&#x27;</span>, depth: 1, noTags: <span class=\"literal\">false</span>, reference: <span class=\"string\">&#x27;&#x27;</span>, shallow: <span class=\"literal\">true</span>,   <span class=\"built_in\">timeout</span>: 30]], submoduleCfg: [],</span><br><span class=\"line\">      userRemoteConfigs: [[credentialsId: <span class=\"string\">&#x27;d1cbab74-823d-41aa-abb7&#x27;</span>, url: <span class=\"string\">&#x27;https://git.yourcompany.com/scm/cppcheck-example.git&#x27;</span>]]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stage(<span class=\"string\">&quot;Cppcheck&quot;</span>)&#123;</span><br><span class=\"line\">    steps&#123;</span><br><span class=\"line\">      script &#123;</span><br><span class=\"line\">        sh <span class=\"string\">&#x27;cppcheck src/public src/themes --xml 2&gt; cppcheck.xml&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stage(<span class=\"string\">&#x27;Publish results&#x27;</span>)&#123;</span><br><span class=\"line\">    steps &#123;</span><br><span class=\"line\">      recordIssues(tools: [cppCheck(pattern: <span class=\"string\">&#x27;cppcheck.xml&#x27;</span>)])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"报告展示\"><a href=\"#报告展示\" class=\"headerlink\" title=\"报告展示\"></a>报告展示</h3><p>我将 CPPCheck 应用到每个 Pull Request 里，当开发提交新的代码时，CPPCheck 就会去扫描代码，然后跟之前的历史记录做对比。CPPCheck 执行成功并生成报告，这里会出现一个按钮，点击进入。</p>\n<p><img src=\"/2020/02/cppcheck/cppcheck-icon.png\" alt=\"CPPCheck 入口\"></p>\n<p>打开之后就会当前分支代码的扫结果。</p>\n<p><img src=\"/2020/02/cppcheck/cppcheck-view.png\" alt=\"CPPCheck 当前的结果\"></p>\n<p>CPPCheck 有三个维度来来展示静态代码扫描结果：</p>\n<ol>\n<li><p>严重程度分布（Severities Distribution）：这里分为 High，Normal，Low 三种级别</p>\n</li>\n<li><p>参考比较（Reference Comparison）：这里会参考之前的数据进行比较，如果有新增就会显示 New，如果是现存的就显示为 Outstanding，如果减少了就会显示 Fixed</p>\n</li>\n<li><p>历史（History）：随着代码的增加和修改，这里会显示一个历史记录的趋势</p>\n</li>\n</ol>\n<p>注意：cppcheck 相关的 xml 是存储在 Jenkins master 上，只有当前的 Jenkins Job 被人为删掉，那么 cppcheck xml 才会被删掉。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-sh-4.2$ <span class=\"built_in\">ls</span> -l cppcheck*</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins 418591 Feb 27 05:54 cppcheck-blames.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins    219 Feb 27 05:54 cppcheck-fixed-issues.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins 142298 Feb 27 05:54 cppcheck-forensics.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins    219 Feb 27 05:54 cppcheck-new-issues.xml</span><br><span class=\"line\">-rw-r--r-- 1 jenkins jenkins 488636 Feb 27 05:54 cppcheck-outstanding-issues.xml</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2020/02/cppcheck/cppcheck-code.png\" alt=\"查看具体 Warining 代码\"></p>\n<p>点击相应的连接就可以直接跳转到具体的代码警告位置了。</p>\n<p>它是不是还挺香的？</p>","categories":[{"name":"Jenkins","path":"api/categories/Jenkins.json"}],"tags":[{"name":"Jenkins","path":"api/tags/Jenkins.json"},{"name":"Cppcheck","path":"api/tags/Cppcheck.json"}]}