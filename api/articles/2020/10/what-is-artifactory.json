{"title":"写给那些想使用 JFrog Artifactory 管理制品的人","slug":"2020/10/what-is-artifactory","date":"2020-10-04T12:43:46.000Z","updated":"2024-09-30T16:52:12.548Z","comments":true,"path":"api/articles/2020/10/what-is-artifactory.json","excerpt":"我在使用 Artifactory 做持续集成已经有一段时间了，对企业级 Artifactory 也有了一些经验和总结，希望能通过本篇的分享帮助刚接触这个工具的人了解什么是Artifactory，它能做什么，为什么要选择它，以及在使用过程中应该注意什么。什么是Artifactory一句话概括：Artifactory 是一个存放制品（Artifacts）的工具。当前，Artifactory 是一个非常有影响力，功能非常强大的工具。Artifactory有哪些优势可能你的团队已经有了自己的管理制品的方式，比如 FTP 等。Artifactory 能带来什么呢？让我先来看看它有哪些优势。注：以下优势都是针对 JFrog Aritifacvtory 企业版来介绍的。开源版，即 OSS 版本不具备以下丰富的功能。优势1：它是一个通用管理仓库JFrog Artifactory 企业版完全支持所有主要包格式的存储库管理器。它不但可以管理二进制文件，也可以对市面上几乎所有语言的包的依赖进行管理，如下图所示 [Figure] 因此，使用 Artifactory 能够将所有的二进制文件和包存储在一个地方。","covers":["/2020/10/what-is-artifactory/support-package-formats.png","/2020/10/what-is-artifactory/ci-tools.png","/2020/10/what-is-artifactory/search-by-name.png","/2020/10/what-is-artifactory/search-by-property.png","/2020/10/what-is-artifactory/search-by-checksum.png","/2020/10/what-is-artifactory/artifactory-home.png","/2020/10/what-is-artifactory/artifactory-artifacts.png"],"content":"<p>我在使用 Artifactory 做持续集成已经有一段时间了，对企业级 Artifactory 也有了一些经验和总结，希望能通过本篇的分享帮助刚接触这个工具的人了解什么是Artifactory，它能做什么，为什么要选择它，以及在使用过程中应该注意什么。</p>\n<h2 id=\"什么是Artifactory\"><a href=\"#什么是Artifactory\" class=\"headerlink\" title=\"什么是Artifactory\"></a>什么是Artifactory</h2><p>一句话概括：Artifactory 是一个存放制品（Artifacts）的工具。当前，Artifactory 是一个非常有影响力，功能非常强大的工具。</p>\n<h2 id=\"Artifactory有哪些优势\"><a href=\"#Artifactory有哪些优势\" class=\"headerlink\" title=\"Artifactory有哪些优势\"></a>Artifactory有哪些优势</h2><p>可能你的团队已经有了自己的管理制品的方式，比如 FTP 等。Artifactory 能带来什么呢？让我先来看看它有哪些优势。</p>\n<blockquote>\n<p>注：以下优势都是针对 JFrog Aritifacvtory 企业版来介绍的。开源版，即 OSS 版本不具备以下丰富的功能。</p>\n</blockquote>\n<h3 id=\"优势1：它是一个通用管理仓库\"><a href=\"#优势1：它是一个通用管理仓库\" class=\"headerlink\" title=\"优势1：它是一个通用管理仓库\"></a>优势1：它是一个通用管理仓库</h3><p>JFrog Artifactory 企业版完全支持所有主要包格式的存储库管理器。它不但可以管理二进制文件，也可以对市面上几乎所有语言的包的依赖进行管理，如下图所示</p>\n<p><img src=\"/2020/10/what-is-artifactory/support-package-formats.png\" alt=\"主要的包格式\"></p>\n<p>因此，使用 Artifactory 能够将所有的二进制文件和包存储在<strong>一个地方</strong>。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"优势2：跟-CI-工具更好的集成\"><a href=\"#优势2：跟-CI-工具更好的集成\" class=\"headerlink\" title=\"优势2：跟 CI 工具更好的集成\"></a>优势2：跟 CI 工具更好的集成</h3><p>它支持所有主流 CI 工具（如下图所示），并在部署期间能捕获详尽的构建环境信息，以实现可完全复制的构建</p>\n<p><img src=\"/2020/10/what-is-artifactory/ci-tools.png\" alt=\"支持的 CI 工具\"></p>\n<p>另外通过提供的丰富的 REST API，因此 GUI 页面上的任何操作都可以通过代码以编程方式完成，方便实现 CI&#x2F;CD。</p>\n<h3 id=\"优势3：提供强大的搜索功能\"><a href=\"#优势3：提供强大的搜索功能\" class=\"headerlink\" title=\"优势3：提供强大的搜索功能\"></a>优势3：提供强大的搜索功能</h3><p>如果你的构建是存储在 FTP 上，想从大量的制品中找到你要找的那一个，如果不知道它的名字，那么真的很难找到它。</p>\n<p>Artifactory 提供了强大的搜索功能，可以通过带有正则表达的名字进行搜索；还可以通过文件的 checksum；以及通过属性（Properties）等方式进行快速搜索，如下示例</p>\n<h4 id=\"例1：通过名字搜索\"><a href=\"#例1：通过名字搜索\" class=\"headerlink\" title=\"例1：通过名字搜索\"></a>例1：通过名字搜索</h4><p>你想找某一个提交点的构建制品，比如那个提交点的 commit hash 是 <code>a422912</code>，那么你就可以直接输入 <code>*a422912*</code> 回车，就能快速的从众多的制品中找到，例如 Demo_Linux_bin_a422912.zip</p>\n<p><img src=\"/2020/10/what-is-artifactory/search-by-name.png\" alt=\"通过名字来搜索\"></p>\n<h4 id=\"例2：通过属性搜索\"><a href=\"#例2：通过属性搜索\" class=\"headerlink\" title=\"例2：通过属性搜索\"></a>例2：通过属性搜索</h4><p>比如要找属性 <code>release.status</code> 为 <code>released</code> 的所有构建那么就可以这样搜索。</p>\n<p><img src=\"/2020/10/what-is-artifactory/search-by-property.png\" alt=\"通过属性来搜索\"></p>\n<h4 id=\"例3：通过-checksum-搜索\"><a href=\"#例3：通过-checksum-搜索\" class=\"headerlink\" title=\"例3：通过 checksum 搜索\"></a>例3：通过 checksum 搜索</h4><p>如果只知道文件的 <code>checksum</code>，同样也可以进行搜索。例如通过 <code>sha1sum</code> 计算出文件的 <code>checksum</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sha1sum</span> test.zip</span><br><span class=\"line\">ad62c72fb097fc4aa7723e1fc72b08a6ebcacfd1 *test.zip</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2020/10/what-is-artifactory/search-by-checksum.png\" alt=\"通过 Checksum 来搜索\"></p>\n<h3 id=\"优势4：管理制品的生命周期\"><a href=\"#优势4：管理制品的生命周期\" class=\"headerlink\" title=\"优势4：管理制品的生命周期\"></a>优势4：管理制品的生命周期</h3><p>通过定义不同成熟度存储库，然后使用 Artifactory <code>Promote</code> 功能可以将制品移动到不同的成熟度存储库，以及通过元数据属性，更好的管理和维护制品的生命周期。</p>\n<p>除了这些优势之外，Artifactory 还有更多的特点，我就不一一介绍了。</p>\n<blockquote>\n<p>更多功能可以浏览 JFrog Artifactory 的官方介绍 <a href=\"https://jfrog.com/artifactory/features/\">https://jfrog.com/artifactory/features/</a></p>\n</blockquote>\n<p>接下来通过一个 Demo 来介绍 Artifactory 应该怎么使用，以及其中有哪些最佳实践，避免走弯路。</p>\n<h2 id=\"Artifactory首页介绍\"><a href=\"#Artifactory首页介绍\" class=\"headerlink\" title=\"Artifactory首页介绍\"></a>Artifactory首页介绍</h2><p><img src=\"/2020/10/what-is-artifactory/artifactory-home.png\" alt=\"Artifactory Home\"></p>\n<h3 id=\"页面顶部\"><a href=\"#页面顶部\" class=\"headerlink\" title=\"页面顶部\"></a>页面顶部</h3><p>你可以看到这个 Artifactory 已经服务了超过 5000 件的制品。还可以看到 Artifactory 的当前版本号，以及最新版本。</p>\n<h3 id=\"页面中部，从左到右\"><a href=\"#页面中部，从左到右\" class=\"headerlink\" title=\"页面中部，从左到右\"></a>页面中部，从左到右</h3><ol>\n<li><p>最左边是搜索功能，通过丰富的搜索条件可以轻松找到制品。然后是一些用户手册、视频、REST API 文档等信息。</p>\n</li>\n<li><p>中间是 Set Me Up，使用它可以选择和筛选你想要操作的存储库，点击特定的存储库可以弹出关于如何使用它的详细说明。</p>\n</li>\n<li><p>最右边是显示的是最近部署的构建和最多下载量的制品（<code>95</code>代表的是下载次数）</p>\n</li>\n</ol>\n<h3 id=\"页面底部\"><a href=\"#页面底部\" class=\"headerlink\" title=\"页面底部\"></a>页面底部</h3><p>在底部是一些与 Artifactory 集成的相关工具和技术用户文档，方便做集成时快速找到找到最权威的技术资料。</p>\n<h2 id=\"实践和工作流\"><a href=\"#实践和工作流\" class=\"headerlink\" title=\"实践和工作流\"></a>实践和工作流</h2><h3 id=\"设置关注的仓库\"><a href=\"#设置关注的仓库\" class=\"headerlink\" title=\"设置关注的仓库\"></a>设置关注的仓库</h3><p>在首页的 Set Me Up 里你也看到了我们有很多仓库（Repository），然而在众多仓库中，大多数成员只对其中一些仓库感兴趣，那么就可以只关注部分仓库。添加喜欢，然后点击喜欢按钮就可以只列出你关注的 Artifact Repository 了。</p>\n<p><img src=\"/2020/10/what-is-artifactory/artifactory-artifacts.png\" alt=\"Artifacts\"></p>\n<h3 id=\"仓库权限与保留策略\"><a href=\"#仓库权限与保留策略\" class=\"headerlink\" title=\"仓库权限与保留策略\"></a>仓库权限与保留策略</h3><table>\n<thead>\n<tr>\n<th>仓库(maturity)</th>\n<th>保留策略(Retention)</th>\n<th>个人账户(Personal Account)</th>\n<th>服务账户(Service Account)</th>\n<th>管理员(Admin)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dev</td>\n<td>通常不清理</td>\n<td>read&#x2F;write</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n<tr>\n<td>int</td>\n<td>一周或是几天</td>\n<td>read</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n<tr>\n<td>stage</td>\n<td>永不清理</td>\n<td>read</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n<tr>\n<td>release</td>\n<td>永不清理</td>\n<td>read</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n</tbody></table>\n<p>通过表格很容易了解这个权限的设置和保留策略，这适合大多数的情况，但不一定适合所有企业情况。</p>\n<h3 id=\"Artifactory仓库命名方法\"><a href=\"#Artifactory仓库命名方法\" class=\"headerlink\" title=\"Artifactory仓库命名方法\"></a>Artifactory仓库命名方法</h3><p>在这个列表仓库中，你可以从这些仓库的名称中看到遵循了某些命名约定，这里遵循了 <a href=\"https://jfrog.com/whitepaper/best-practices-structuring-naming-artifactory-repositories/\">JFrog Artifactory 推荐的官方命名</a> 方法，强烈建议你也这么做。它是由四部分组成：</p>\n<p><code>&lt;team&gt;-&lt;technology&gt;-&lt;maturity&gt;-&lt;locator&gt;</code></p>\n<ul>\n<li>图上的 team 我做了脱敏，我们叫它叫 team1 吧。</li>\n<li>然后是技术，这里有很多可选的，比如 generic, Docker, Maven, NPM 等等。我用的 generic，这是由于我们的产品是 C&#x2F;C++ 编译出来的二进制文件，它属于 generic 类别。</li>\n<li>接下来是成熟度（maturity），一个仓库通常由四个级别的成熟度组成，从低到高这里分别是 <code>dev</code>, <code>int</code>, <code>stage</code> 和 <code>release</code>。</li>\n<li>最后是表示制品的所在位置。比如一个跨国公司，它可能在不同区域都有 Aritfacotory 实例来保证上传&#x2F;下载速度等需求。图上的 den 就是当前 Artifactory 所在位置的缩写。</li>\n</ul>\n<h3 id=\"从构建生成到发布了解它的工作流\"><a href=\"#从构建生成到发布了解它的工作流\" class=\"headerlink\" title=\"从构建生成到发布了解它的工作流\"></a>从构建生成到发布了解它的工作流</h3><p><code>dev</code> 意味着 development（开发），该仓库对所有产品成员都具有读写权限，他们可以上传一些库或其他一些二进制文件。</p>\n<p><code>int</code> 表示 integration（集成），比如从 Jenkins 里成功构建的制品将首先放在这个存储库下，如果构建失败，它将不会被上传到 Artifactory。</p>\n<p><code>stage</code> 表示预发布仓库，通过 Unit Test&#x2F;Smoke Test 的制品会被 <code>Promote</code> 这个仓库待进一步测试，比如手动测试。</p>\n<p><code>release</code> 通过测试的制品会被 <code>Promote</code> 到这个仓库下。</p>\n<p>为了更好的管理Artifactory目录和制品的生命周期，我建议<strong>规范分支命名</strong>和对不同阶段的制品<strong>添加属性</strong>。</p>\n<h4 id=\"1-规范分支命名有利于Artifactory的目录清晰\"><a href=\"#1-规范分支命名有利于Artifactory的目录清晰\" class=\"headerlink\" title=\"1. 规范分支命名有利于Artifactory的目录清晰\"></a>1. 规范分支命名有利于Artifactory的目录清晰</h4><p>例如，一个产品叫 ART，它的 Git 仓库也叫 ART，它下面有这样一个分支 <code>feature/ART-1234</code>。</p>\n<p>Jenkins Pipeline 里的环境变量设置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">environment &#123;</span><br><span class=\"line\">  INT_REPO_PATH = &quot;team1-generic-int-den/ART/$&#123;BRANCH_NAME&#125;/$&#123;BUILD_NUMBER&#125;/&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看看这个分支构建是如何流转的。</p>\n<p>这个分支通过 Jenkins 第1构建成功后，它首先会被 <code>team1-generic-int-den</code> 仓库下的 <code>ART/feature/ART-1234/1/</code> 的目录下面，如果进行第2次构建，并成功，那么它的制品目录会是：<br><code>team1-generic-int-den/ART/feature/ART-1234/2/</code> 以此类推。</p>\n<p>为了更好的管理仓库下面的目录，建议团队事先约定分支命名规范，这样同一种类型的分支的所有构建都会出现在一个目录下面。</p>\n<p>关于命名规范可参见这篇文章<a href=\"https://shenxianpeng.github.io/2020/09/commit-messages-specification/\">程序员自我修养之Git提交信息和分支创建规范</a></p>\n<p>对于 Pull Request Build 如果也想放到 Artifactory 上面，建议像下面这样设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">environment &#123;</span><br><span class=\"line\">  PR_INT_REPO_PATH = &quot;team1-generic-int-den/ART/PRs/$&#123;BRANCH_NAME&#125;/$&#123;BUILD_NUMBER&#125;/&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样所有的 Pull Request Build 构建成功后都会被放到 <code>PRs</code> 这个目录下，方便查找和管理。</p>\n<h4 id=\"2-不同阶段添加不同的属性\"><a href=\"#2-不同阶段添加不同的属性\" class=\"headerlink\" title=\"2. 不同阶段添加不同的属性\"></a>2. 不同阶段添加不同的属性</h4><p>如果以上的构建通过了一些质量关卡，比如通过了单元测试、自动化测试以及 SonaQube 的扫描等等，建议添加不同的属性，例如：</p>\n<p><code>unit.test.status=passed</code><br><code>automated.test.status=passed</code><br><code>sonaqube.scan.status=passed</code></p>\n<p>然后根据上面的状态，将符合条件的制品从 <code>int</code> 仓库 Promote 到 <code>stage</code> 仓库，测试工程师进去 <code>stage</code> 仓库下去获取构建并进行测试。通过测试后，对制品添加相应的属性状态，比如在 Property 中添加 <code>manual.test.status=passed</code>。</p>\n<p>之后发布流水线中去到 stage 仓库里去找满足所有条件的构建进行发布。</p>\n<p><code>unit.test.status=passed</code><br><code>automated.test.status=passed</code><br><code>sonaqube.scan.status=passed</code><br><code>manual.test.status=passed</code></p>\n<p>发布成功后，将构建从 <code>stage</code> 仓库 promote 到 <code>release</code> 仓库中，并添加属性 <code>release.status=released</code>，这样就完成了发布。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在软件交付中，质量可信、安全可信是评估版本可靠性的两个重要标准。在这个过程中，就像使用漏斗一样将构建通过层层筛选，从 <code>int</code> 仓库到 <code>stage</code> 仓库，最后到 <code>release</code> 仓库完成了制品的发布。通过 Artifactory 为制品管理的打造一个单一可信源，从而为软件的持续交付铺路。</p>\n<h2 id=\"往期相关文章\"><a href=\"#往期相关文章\" class=\"headerlink\" title=\"往期相关文章\"></a>往期相关文章</h2><ul>\n<li><a href=\"https://shenxianpeng.github.io/2019/11/Artifactory-install-and-upgrade/\">初识 JFrog Artifactory</a></li>\n<li><a href=\"https://shenxianpeng.github.io/2019/11/Artifactory-integrate-with-Jenkins/\">Artifactory 与 Jenkins 集成</a></li>\n<li><a href=\"https://shenxianpeng.github.io/2020/06/Java-net-SocketException-on-AIX/\">解决 Jenkins Artifactory Plugin 仅在 AIX 上传制品到 https 协议的 Artifactory 失败的问题</a></li>\n</ul>\n","more":"<h3 id=\"优势2：跟-CI-工具更好的集成\"><a href=\"#优势2：跟-CI-工具更好的集成\" class=\"headerlink\" title=\"优势2：跟 CI 工具更好的集成\"></a>优势2：跟 CI 工具更好的集成</h3><p>它支持所有主流 CI 工具（如下图所示），并在部署期间能捕获详尽的构建环境信息，以实现可完全复制的构建</p>\n<p><img src=\"/2020/10/what-is-artifactory/ci-tools.png\" alt=\"支持的 CI 工具\"></p>\n<p>另外通过提供的丰富的 REST API，因此 GUI 页面上的任何操作都可以通过代码以编程方式完成，方便实现 CI&#x2F;CD。</p>\n<h3 id=\"优势3：提供强大的搜索功能\"><a href=\"#优势3：提供强大的搜索功能\" class=\"headerlink\" title=\"优势3：提供强大的搜索功能\"></a>优势3：提供强大的搜索功能</h3><p>如果你的构建是存储在 FTP 上，想从大量的制品中找到你要找的那一个，如果不知道它的名字，那么真的很难找到它。</p>\n<p>Artifactory 提供了强大的搜索功能，可以通过带有正则表达的名字进行搜索；还可以通过文件的 checksum；以及通过属性（Properties）等方式进行快速搜索，如下示例</p>\n<h4 id=\"例1：通过名字搜索\"><a href=\"#例1：通过名字搜索\" class=\"headerlink\" title=\"例1：通过名字搜索\"></a>例1：通过名字搜索</h4><p>你想找某一个提交点的构建制品，比如那个提交点的 commit hash 是 <code>a422912</code>，那么你就可以直接输入 <code>*a422912*</code> 回车，就能快速的从众多的制品中找到，例如 Demo_Linux_bin_a422912.zip</p>\n<p><img src=\"/2020/10/what-is-artifactory/search-by-name.png\" alt=\"通过名字来搜索\"></p>\n<h4 id=\"例2：通过属性搜索\"><a href=\"#例2：通过属性搜索\" class=\"headerlink\" title=\"例2：通过属性搜索\"></a>例2：通过属性搜索</h4><p>比如要找属性 <code>release.status</code> 为 <code>released</code> 的所有构建那么就可以这样搜索。</p>\n<p><img src=\"/2020/10/what-is-artifactory/search-by-property.png\" alt=\"通过属性来搜索\"></p>\n<h4 id=\"例3：通过-checksum-搜索\"><a href=\"#例3：通过-checksum-搜索\" class=\"headerlink\" title=\"例3：通过 checksum 搜索\"></a>例3：通过 checksum 搜索</h4><p>如果只知道文件的 <code>checksum</code>，同样也可以进行搜索。例如通过 <code>sha1sum</code> 计算出文件的 <code>checksum</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sha1sum</span> test.zip</span><br><span class=\"line\">ad62c72fb097fc4aa7723e1fc72b08a6ebcacfd1 *test.zip</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2020/10/what-is-artifactory/search-by-checksum.png\" alt=\"通过 Checksum 来搜索\"></p>\n<h3 id=\"优势4：管理制品的生命周期\"><a href=\"#优势4：管理制品的生命周期\" class=\"headerlink\" title=\"优势4：管理制品的生命周期\"></a>优势4：管理制品的生命周期</h3><p>通过定义不同成熟度存储库，然后使用 Artifactory <code>Promote</code> 功能可以将制品移动到不同的成熟度存储库，以及通过元数据属性，更好的管理和维护制品的生命周期。</p>\n<p>除了这些优势之外，Artifactory 还有更多的特点，我就不一一介绍了。</p>\n<blockquote>\n<p>更多功能可以浏览 JFrog Artifactory 的官方介绍 <a href=\"https://jfrog.com/artifactory/features/\">https://jfrog.com/artifactory/features/</a></p>\n</blockquote>\n<p>接下来通过一个 Demo 来介绍 Artifactory 应该怎么使用，以及其中有哪些最佳实践，避免走弯路。</p>\n<h2 id=\"Artifactory首页介绍\"><a href=\"#Artifactory首页介绍\" class=\"headerlink\" title=\"Artifactory首页介绍\"></a>Artifactory首页介绍</h2><p><img src=\"/2020/10/what-is-artifactory/artifactory-home.png\" alt=\"Artifactory Home\"></p>\n<h3 id=\"页面顶部\"><a href=\"#页面顶部\" class=\"headerlink\" title=\"页面顶部\"></a>页面顶部</h3><p>你可以看到这个 Artifactory 已经服务了超过 5000 件的制品。还可以看到 Artifactory 的当前版本号，以及最新版本。</p>\n<h3 id=\"页面中部，从左到右\"><a href=\"#页面中部，从左到右\" class=\"headerlink\" title=\"页面中部，从左到右\"></a>页面中部，从左到右</h3><ol>\n<li><p>最左边是搜索功能，通过丰富的搜索条件可以轻松找到制品。然后是一些用户手册、视频、REST API 文档等信息。</p>\n</li>\n<li><p>中间是 Set Me Up，使用它可以选择和筛选你想要操作的存储库，点击特定的存储库可以弹出关于如何使用它的详细说明。</p>\n</li>\n<li><p>最右边是显示的是最近部署的构建和最多下载量的制品（<code>95</code>代表的是下载次数）</p>\n</li>\n</ol>\n<h3 id=\"页面底部\"><a href=\"#页面底部\" class=\"headerlink\" title=\"页面底部\"></a>页面底部</h3><p>在底部是一些与 Artifactory 集成的相关工具和技术用户文档，方便做集成时快速找到找到最权威的技术资料。</p>\n<h2 id=\"实践和工作流\"><a href=\"#实践和工作流\" class=\"headerlink\" title=\"实践和工作流\"></a>实践和工作流</h2><h3 id=\"设置关注的仓库\"><a href=\"#设置关注的仓库\" class=\"headerlink\" title=\"设置关注的仓库\"></a>设置关注的仓库</h3><p>在首页的 Set Me Up 里你也看到了我们有很多仓库（Repository），然而在众多仓库中，大多数成员只对其中一些仓库感兴趣，那么就可以只关注部分仓库。添加喜欢，然后点击喜欢按钮就可以只列出你关注的 Artifact Repository 了。</p>\n<p><img src=\"/2020/10/what-is-artifactory/artifactory-artifacts.png\" alt=\"Artifacts\"></p>\n<h3 id=\"仓库权限与保留策略\"><a href=\"#仓库权限与保留策略\" class=\"headerlink\" title=\"仓库权限与保留策略\"></a>仓库权限与保留策略</h3><table>\n<thead>\n<tr>\n<th>仓库(maturity)</th>\n<th>保留策略(Retention)</th>\n<th>个人账户(Personal Account)</th>\n<th>服务账户(Service Account)</th>\n<th>管理员(Admin)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dev</td>\n<td>通常不清理</td>\n<td>read&#x2F;write</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n<tr>\n<td>int</td>\n<td>一周或是几天</td>\n<td>read</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n<tr>\n<td>stage</td>\n<td>永不清理</td>\n<td>read</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n<tr>\n<td>release</td>\n<td>永不清理</td>\n<td>read</td>\n<td>read&#x2F;write</td>\n<td>all</td>\n</tr>\n</tbody></table>\n<p>通过表格很容易了解这个权限的设置和保留策略，这适合大多数的情况，但不一定适合所有企业情况。</p>\n<h3 id=\"Artifactory仓库命名方法\"><a href=\"#Artifactory仓库命名方法\" class=\"headerlink\" title=\"Artifactory仓库命名方法\"></a>Artifactory仓库命名方法</h3><p>在这个列表仓库中，你可以从这些仓库的名称中看到遵循了某些命名约定，这里遵循了 <a href=\"https://jfrog.com/whitepaper/best-practices-structuring-naming-artifactory-repositories/\">JFrog Artifactory 推荐的官方命名</a> 方法，强烈建议你也这么做。它是由四部分组成：</p>\n<p><code>&lt;team&gt;-&lt;technology&gt;-&lt;maturity&gt;-&lt;locator&gt;</code></p>\n<ul>\n<li>图上的 team 我做了脱敏，我们叫它叫 team1 吧。</li>\n<li>然后是技术，这里有很多可选的，比如 generic, Docker, Maven, NPM 等等。我用的 generic，这是由于我们的产品是 C&#x2F;C++ 编译出来的二进制文件，它属于 generic 类别。</li>\n<li>接下来是成熟度（maturity），一个仓库通常由四个级别的成熟度组成，从低到高这里分别是 <code>dev</code>, <code>int</code>, <code>stage</code> 和 <code>release</code>。</li>\n<li>最后是表示制品的所在位置。比如一个跨国公司，它可能在不同区域都有 Aritfacotory 实例来保证上传&#x2F;下载速度等需求。图上的 den 就是当前 Artifactory 所在位置的缩写。</li>\n</ul>\n<h3 id=\"从构建生成到发布了解它的工作流\"><a href=\"#从构建生成到发布了解它的工作流\" class=\"headerlink\" title=\"从构建生成到发布了解它的工作流\"></a>从构建生成到发布了解它的工作流</h3><p><code>dev</code> 意味着 development（开发），该仓库对所有产品成员都具有读写权限，他们可以上传一些库或其他一些二进制文件。</p>\n<p><code>int</code> 表示 integration（集成），比如从 Jenkins 里成功构建的制品将首先放在这个存储库下，如果构建失败，它将不会被上传到 Artifactory。</p>\n<p><code>stage</code> 表示预发布仓库，通过 Unit Test&#x2F;Smoke Test 的制品会被 <code>Promote</code> 这个仓库待进一步测试，比如手动测试。</p>\n<p><code>release</code> 通过测试的制品会被 <code>Promote</code> 到这个仓库下。</p>\n<p>为了更好的管理Artifactory目录和制品的生命周期，我建议<strong>规范分支命名</strong>和对不同阶段的制品<strong>添加属性</strong>。</p>\n<h4 id=\"1-规范分支命名有利于Artifactory的目录清晰\"><a href=\"#1-规范分支命名有利于Artifactory的目录清晰\" class=\"headerlink\" title=\"1. 规范分支命名有利于Artifactory的目录清晰\"></a>1. 规范分支命名有利于Artifactory的目录清晰</h4><p>例如，一个产品叫 ART，它的 Git 仓库也叫 ART，它下面有这样一个分支 <code>feature/ART-1234</code>。</p>\n<p>Jenkins Pipeline 里的环境变量设置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">environment &#123;</span><br><span class=\"line\">  INT_REPO_PATH = &quot;team1-generic-int-den/ART/$&#123;BRANCH_NAME&#125;/$&#123;BUILD_NUMBER&#125;/&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看看这个分支构建是如何流转的。</p>\n<p>这个分支通过 Jenkins 第1构建成功后，它首先会被 <code>team1-generic-int-den</code> 仓库下的 <code>ART/feature/ART-1234/1/</code> 的目录下面，如果进行第2次构建，并成功，那么它的制品目录会是：<br><code>team1-generic-int-den/ART/feature/ART-1234/2/</code> 以此类推。</p>\n<p>为了更好的管理仓库下面的目录，建议团队事先约定分支命名规范，这样同一种类型的分支的所有构建都会出现在一个目录下面。</p>\n<p>关于命名规范可参见这篇文章<a href=\"https://shenxianpeng.github.io/2020/09/commit-messages-specification/\">程序员自我修养之Git提交信息和分支创建规范</a></p>\n<p>对于 Pull Request Build 如果也想放到 Artifactory 上面，建议像下面这样设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">environment &#123;</span><br><span class=\"line\">  PR_INT_REPO_PATH = &quot;team1-generic-int-den/ART/PRs/$&#123;BRANCH_NAME&#125;/$&#123;BUILD_NUMBER&#125;/&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样所有的 Pull Request Build 构建成功后都会被放到 <code>PRs</code> 这个目录下，方便查找和管理。</p>\n<h4 id=\"2-不同阶段添加不同的属性\"><a href=\"#2-不同阶段添加不同的属性\" class=\"headerlink\" title=\"2. 不同阶段添加不同的属性\"></a>2. 不同阶段添加不同的属性</h4><p>如果以上的构建通过了一些质量关卡，比如通过了单元测试、自动化测试以及 SonaQube 的扫描等等，建议添加不同的属性，例如：</p>\n<p><code>unit.test.status=passed</code><br><code>automated.test.status=passed</code><br><code>sonaqube.scan.status=passed</code></p>\n<p>然后根据上面的状态，将符合条件的制品从 <code>int</code> 仓库 Promote 到 <code>stage</code> 仓库，测试工程师进去 <code>stage</code> 仓库下去获取构建并进行测试。通过测试后，对制品添加相应的属性状态，比如在 Property 中添加 <code>manual.test.status=passed</code>。</p>\n<p>之后发布流水线中去到 stage 仓库里去找满足所有条件的构建进行发布。</p>\n<p><code>unit.test.status=passed</code><br><code>automated.test.status=passed</code><br><code>sonaqube.scan.status=passed</code><br><code>manual.test.status=passed</code></p>\n<p>发布成功后，将构建从 <code>stage</code> 仓库 promote 到 <code>release</code> 仓库中，并添加属性 <code>release.status=released</code>，这样就完成了发布。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在软件交付中，质量可信、安全可信是评估版本可靠性的两个重要标准。在这个过程中，就像使用漏斗一样将构建通过层层筛选，从 <code>int</code> 仓库到 <code>stage</code> 仓库，最后到 <code>release</code> 仓库完成了制品的发布。通过 Artifactory 为制品管理的打造一个单一可信源，从而为软件的持续交付铺路。</p>\n<h2 id=\"往期相关文章\"><a href=\"#往期相关文章\" class=\"headerlink\" title=\"往期相关文章\"></a>往期相关文章</h2><ul>\n<li><a href=\"https://shenxianpeng.github.io/2019/11/Artifactory-install-and-upgrade/\">初识 JFrog Artifactory</a></li>\n<li><a href=\"https://shenxianpeng.github.io/2019/11/Artifactory-integrate-with-Jenkins/\">Artifactory 与 Jenkins 集成</a></li>\n<li><a href=\"https://shenxianpeng.github.io/2020/06/Java-net-SocketException-on-AIX/\">解决 Jenkins Artifactory Plugin 仅在 AIX 上传制品到 https 协议的 Artifactory 失败的问题</a></li>\n</ul>","categories":[{"name":"JFrog","path":"api/categories/JFrog.json"}],"tags":[{"name":"Artifactory","path":"api/tags/Artifactory.json"},{"name":"JFrog","path":"api/tags/JFrog.json"}]}