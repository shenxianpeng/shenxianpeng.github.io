{"title":"如何给你的 Git 仓库“瘦身”","slug":"2020/03/maintaining-git-repository","date":"2020-03-21T12:54:34.000Z","updated":"2023-07-17T14:03:32.164Z","comments":true,"path":"api/articles/2020/03/maintaining-git-repository.json","excerpt":"对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文主要讨论如何从 Git 仓库中删除不需要的文件。","covers":null,"content":"<p>对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文主要讨论如何从 Git 仓库中删除不需要的文件。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>请格外小心…..</p>\n<p>本文中的步骤和工具使用的高级技术涉及破坏性操作。确保您在开始之前仔细读过并备份了你的仓库，创建一个备份最容易的方式是使用 –mirror 标志对你的仓库克隆，然后对整个克隆的文件进行打包压缩。有了这个备份，如果在维护期间意外损坏了你的仓库的关键元素，那么你可以通过备份的仓库来恢复。</p>\n<p>请记住，仓库维护对仓库的用户可能会是毁灭性的。与你的团队或者仓库的关注者进行沟通会是很有必要的。确保每个人都已经检查了他们的代码，并且同意在仓库维护期间停止开发。</p>\n</blockquote>\n<h2 id=\"理解从-Git-的历史记录中删除文件\"><a href=\"#理解从-Git-的历史记录中删除文件\" class=\"headerlink\" title=\"理解从 Git 的历史记录中删除文件\"></a>理解从 Git 的历史记录中删除文件</h2><p>回想一下，克隆仓库会克隆整个历史记录——包括每个源代码文件的所有版本。如果一个用户提交了一个较大的文件，比如一个 JAR，则随后的每次克隆都会包含这个文件。即使用户最终在后面的某次提交中删除了这个文件，但是这个文件仍然存在于这个仓库的历史记录中。要想完全的从你的仓库中删除这个文件，你必须：</p>\n<ul>\n<li>从你的项目的当前的文件树中删除该文件;</li>\n<li>从仓库的历史记录中删除文件——重写 Git 历史记录，从包含该文件的所有的提交中删除这个文件;</li>\n<li>删除指向旧的提交历史记录的所有 reflog 历史记录;</li>\n<li>重新整理仓库，使用 <code>git gc</code> 对现在没有使用的数据进行垃圾回收。</li>\n</ul>\n<p>Git 的 <code>gc</code>（垃圾回收）将通过你的任何一个分支或者标签来删除仓库中所有的实际没用的或者以某种方式引用的数据。为了使其发挥作用，我们需要重写包含不需要的文件的所有 Git 仓库历史记录，仓库将不再引用它 <code>git gc</code> 将会丢弃所有没用的数据。</p>\n<p>重写存储库历史是一个棘手的事情，因为每个提交都依赖它的父提交，所以任何一个很小的改变都会改变它的每一个随后的提交的提交。有两个自动化的工具可以帮助你做这件事：</p>\n<ol>\n<li><code>BFG Repo Cleaner</code> —— 快速、简单且易于使用，需要 Java 6 或者更高版本的运行环境。</li>\n<li><code>git filter-branch</code> —— 功能强大、配置麻烦，用于大于仓库时速度较慢，是核心 Git 套件的一部分。</li>\n</ol>\n<p>切记，当你重写历史记录后，无论你是使用 BFG 还是使用 filter-branch，你都需要删除指向旧的历史记录的 <code>reflog</code> 条目，最后运行垃圾回收器来删除旧的数据。</p>\n<h2 id=\"使用-BFG-重写历史记录\"><a href=\"#使用-BFG-重写历史记录\" class=\"headerlink\" title=\"使用 BFG 重写历史记录\"></a>使用 BFG 重写历史记录</h2><p>BFG 是为将像大文件或者密码这些不想要的数据从 Git 仓库中删除而专门设计的，所以它有一一个简单的标志用来删除那些大的历史文件（不在当前的提交里面）：<code>--strip-blobs-bigger-than</code></p>\n<p>BFG <a href=\"https://repo1.maven.org/maven2/com/madgag/bfg\">下载地址</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar bfg.jar --strip-blobs-than 100M</span><br></pre></td></tr></table></figure>\n\n<p>大小超过 100MB 的任何文件（不包含在你最近的提交中的文件——因为 BFG 默认会保护你的最新提交的内容）将会从你的 Git 仓库的历史记录中删除。如果你想用名字来指明具体的文件，你也可以这样做：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar bfg.jar --delete-files *.mp4</span><br></pre></td></tr></table></figure>\n\n<p>BFG 的速度要比 git filter-branch 快 10-1000 倍，而且通常更容易使用——查看完整的<a href=\"https://rtyley.github.io/bfg-repo-cleaner/#usage\">使用说明</a>和<a href=\"https://rtyley.github.io/bfg-repo-cleaner/#examples\">示例</a>获取更多细节。</p>\n<h2 id=\"或者，使用-git-filter-branch-来重写历史记录\"><a href=\"#或者，使用-git-filter-branch-来重写历史记录\" class=\"headerlink\" title=\"或者，使用 git filter-branch 来重写历史记录\"></a>或者，使用 git filter-branch 来重写历史记录</h2><p><code>filter-branch</code> 命令可以对 Git 仓库的历史记录重写，就像 BFG 一样，但是过程更慢和更手动化。如果你不知道这些大文件在哪里，那么你第一步就需要找到它们：</p>\n<h3 id=\"手动查看你-Git-仓库中的大文件\"><a href=\"#手动查看你-Git-仓库中的大文件\" class=\"headerlink\" title=\"手动查看你 Git 仓库中的大文件\"></a>手动查看你 Git 仓库中的大文件</h3><p><a href=\"https://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/\">Antony Stubbs</a> 写了一个可以很好地完成这个功能的 BASH 脚本。该脚本可以检查你的包文件的内容并列出大文件。在你开始删除文件之前，请执行以下操作获取并安装此脚本：</p>\n<ol>\n<li><p><a href=\"https://confluence.atlassian.com/bitbucket/files/321848291/321979854/1/1360604134990/git_find_big.sh\">下载脚本</a>到你的本地的系统</p>\n</li>\n<li><p>将它放在一个可以访问你的 Git 仓库的易于找到的位置</p>\n</li>\n<li><p>让脚本成为可执行文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 777 git_find_big.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>克隆仓库到你本地系统</p>\n</li>\n<li><p>改变当前目录到你的仓库根目录</p>\n</li>\n<li><p>手动运行 Git 垃圾回收器</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git gc --auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出 .git 文件夹的大小</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意文件大小，以便随后参考</span></span><br><span class=\"line\"><span class=\"built_in\">du</span> -hs .git/objects</span><br><span class=\"line\">45M .git/objects</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行 <code>git_find_big.sh</code> 脚本来列出你的仓库中的大文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git_find_big.sh</span><br><span class=\"line\">All sizes are <span class=\"keyword\">in</span> kB<span class=\"string\">&#x27;s. The pack column is the size of the object, compressed, inside the pack file.</span></span><br><span class=\"line\"><span class=\"string\">size  pack  SHA                                       location</span></span><br><span class=\"line\"><span class=\"string\">592   580   e3117f48bc305dd1f5ae0df3419a0ce2d9617336  media/img/emojis.jar</span></span><br><span class=\"line\"><span class=\"string\">550   169   b594a7f59ba7ba9daebb20447a87ea4357874f43  media/js/aui/aui-dependencies.jar</span></span><br><span class=\"line\"><span class=\"string\">518   514   22f7f9a84905aaec019dae9ea1279a9450277130  media/images/screenshots/issue-tracker-wiki.jar</span></span><br><span class=\"line\"><span class=\"string\">337   92    1fd8ac97c9fecf74ba6246eacef8288e89b4bff5  media/js/lib/bundle.js</span></span><br><span class=\"line\"><span class=\"string\">240   239   e0c26d9959bd583e5ef32b6206fc8abe5fea8624  media/img/featuretour/heroshot.png</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>大文件都是 JAR 文件，包的大小列是最相关的。aui-dependencies.jar 被压缩到 169kb，但是 emojis.jar 只压缩到 500kb。emojis.jar 就是一个待删除的对象。</p>\n<h3 id=\"运行-filter-branch\"><a href=\"#运行-filter-branch\" class=\"headerlink\" title=\"运行 filter-branch\"></a>运行 filter-branch</h3><p>你可以给这个命令传递一个用于重写 Git 索引的过滤器。例如，一个过滤器可以可以将每个检索的提交删除。这个用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git filter-branch --index-filter <span class=\"string\">&#x27;git rm --cached --ignore-unmatch&amp;nbsp; _pathname_ &#x27;</span> commitHASH</span><br></pre></td></tr></table></figure>\n\n<p><code>--index-filter</code> 选项可以修改仓库的索引，<code>--cached</code> 选项从索引中而不是磁盘来删除文件。这样会更快，因为你不需要在运行这个过滤器前检查每个修订版本。<br><code>git rm</code> 中的 <code>ignore-unmatch</code> 选项可以防止在尝试移走不存在的文件 pathname 的时候命令失败。通过指定一个提交 HASH 值，你可以从每个以这个 HASH 值开始的提交中删除 pathname。要从开始处删除，你可以省略这个参数或者指定为 HEAD。</p>\n<p>如果你的大文件在不同的分支，你将需要通过名字来删除每个文件。如果大文件都在一个单独的分支，你可以直接删除这个分支本身。</p>\n<h4 id=\"选项-1：通过文件名删除文件\"><a href=\"#选项-1：通过文件名删除文件\" class=\"headerlink\" title=\"选项 1：通过文件名删除文件\"></a>选项 1：通过文件名删除文件</h4><p>使用下面的步骤来删除大文件：</p>\n<ol>\n<li><p>使用下面的命令来删除你找到的第一个大文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git filter-branch --index-filter <span class=\"string\">&#x27;git rm --cached --ignore-unmatch filename&#x27;</span> HEAD</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重复步骤 1 找到剩下的每个大文件</p>\n</li>\n<li><p>在你的仓库里更新引用。 <code>filter-branch</code> 会为你原先的引用创建一个 <code>refs/original/</code> 下的备份。一旦你确信已经删除了正确的文件，你可以运行下面的命令来删除备份文件，同时可以让垃圾回收器回收大的对象</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git for-each-ref --format=<span class=\"string\">&quot;%(refname)&quot;</span> refs/original/ | xargs -n 1 git update-ref -d</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"选项-2：直接删除分支\"><a href=\"#选项-2：直接删除分支\" class=\"headerlink\" title=\"选项 2：直接删除分支\"></a>选项 2：直接删除分支</h4><p>如果你所有的大文件都在一个单独的分支上，你可以直接删除这个分支。删除这个分支会自动删除所有的引用。</p>\n<ol>\n<li><p>删除分支</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch -D PROJ567bugfix</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从后面的分支中删除所有的 reflog 引用</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reflog expire --expire=now PROJ567bugfix</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"对不用的数据垃圾回收\"><a href=\"#对不用的数据垃圾回收\" class=\"headerlink\" title=\"对不用的数据垃圾回收\"></a>对不用的数据垃圾回收</h4><ol>\n<li><p>删除从现在到后面的所有 reflog 引用（除非你明确地只在一个分支上操作）</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reflog expire --expire=now --all</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过运行垃圾回收器和删除旧的对象重新打包仓库。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git gc --prune=now</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把你所有的修改推送回仓库</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push --all --force</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确保你所有的标签也是当前最新的</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push --tags --force</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://confluence.atlassian.com/bitbucket/maintaining-a-git-repository-321848291.html\">英文原文地址</a></p>\n","more":"<blockquote>\n<p>请格外小心…..</p>\n<p>本文中的步骤和工具使用的高级技术涉及破坏性操作。确保您在开始之前仔细读过并备份了你的仓库，创建一个备份最容易的方式是使用 –mirror 标志对你的仓库克隆，然后对整个克隆的文件进行打包压缩。有了这个备份，如果在维护期间意外损坏了你的仓库的关键元素，那么你可以通过备份的仓库来恢复。</p>\n<p>请记住，仓库维护对仓库的用户可能会是毁灭性的。与你的团队或者仓库的关注者进行沟通会是很有必要的。确保每个人都已经检查了他们的代码，并且同意在仓库维护期间停止开发。</p>\n</blockquote>\n<h2 id=\"理解从-Git-的历史记录中删除文件\"><a href=\"#理解从-Git-的历史记录中删除文件\" class=\"headerlink\" title=\"理解从 Git 的历史记录中删除文件\"></a>理解从 Git 的历史记录中删除文件</h2><p>回想一下，克隆仓库会克隆整个历史记录——包括每个源代码文件的所有版本。如果一个用户提交了一个较大的文件，比如一个 JAR，则随后的每次克隆都会包含这个文件。即使用户最终在后面的某次提交中删除了这个文件，但是这个文件仍然存在于这个仓库的历史记录中。要想完全的从你的仓库中删除这个文件，你必须：</p>\n<ul>\n<li>从你的项目的当前的文件树中删除该文件;</li>\n<li>从仓库的历史记录中删除文件——重写 Git 历史记录，从包含该文件的所有的提交中删除这个文件;</li>\n<li>删除指向旧的提交历史记录的所有 reflog 历史记录;</li>\n<li>重新整理仓库，使用 <code>git gc</code> 对现在没有使用的数据进行垃圾回收。</li>\n</ul>\n<p>Git 的 <code>gc</code>（垃圾回收）将通过你的任何一个分支或者标签来删除仓库中所有的实际没用的或者以某种方式引用的数据。为了使其发挥作用，我们需要重写包含不需要的文件的所有 Git 仓库历史记录，仓库将不再引用它 <code>git gc</code> 将会丢弃所有没用的数据。</p>\n<p>重写存储库历史是一个棘手的事情，因为每个提交都依赖它的父提交，所以任何一个很小的改变都会改变它的每一个随后的提交的提交。有两个自动化的工具可以帮助你做这件事：</p>\n<ol>\n<li><code>BFG Repo Cleaner</code> —— 快速、简单且易于使用，需要 Java 6 或者更高版本的运行环境。</li>\n<li><code>git filter-branch</code> —— 功能强大、配置麻烦，用于大于仓库时速度较慢，是核心 Git 套件的一部分。</li>\n</ol>\n<p>切记，当你重写历史记录后，无论你是使用 BFG 还是使用 filter-branch，你都需要删除指向旧的历史记录的 <code>reflog</code> 条目，最后运行垃圾回收器来删除旧的数据。</p>\n<h2 id=\"使用-BFG-重写历史记录\"><a href=\"#使用-BFG-重写历史记录\" class=\"headerlink\" title=\"使用 BFG 重写历史记录\"></a>使用 BFG 重写历史记录</h2><p>BFG 是为将像大文件或者密码这些不想要的数据从 Git 仓库中删除而专门设计的，所以它有一一个简单的标志用来删除那些大的历史文件（不在当前的提交里面）：<code>--strip-blobs-bigger-than</code></p>\n<p>BFG <a href=\"https://repo1.maven.org/maven2/com/madgag/bfg\">下载地址</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar bfg.jar --strip-blobs-than 100M</span><br></pre></td></tr></table></figure>\n\n<p>大小超过 100MB 的任何文件（不包含在你最近的提交中的文件——因为 BFG 默认会保护你的最新提交的内容）将会从你的 Git 仓库的历史记录中删除。如果你想用名字来指明具体的文件，你也可以这样做：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar bfg.jar --delete-files *.mp4</span><br></pre></td></tr></table></figure>\n\n<p>BFG 的速度要比 git filter-branch 快 10-1000 倍，而且通常更容易使用——查看完整的<a href=\"https://rtyley.github.io/bfg-repo-cleaner/#usage\">使用说明</a>和<a href=\"https://rtyley.github.io/bfg-repo-cleaner/#examples\">示例</a>获取更多细节。</p>\n<h2 id=\"或者，使用-git-filter-branch-来重写历史记录\"><a href=\"#或者，使用-git-filter-branch-来重写历史记录\" class=\"headerlink\" title=\"或者，使用 git filter-branch 来重写历史记录\"></a>或者，使用 git filter-branch 来重写历史记录</h2><p><code>filter-branch</code> 命令可以对 Git 仓库的历史记录重写，就像 BFG 一样，但是过程更慢和更手动化。如果你不知道这些大文件在哪里，那么你第一步就需要找到它们：</p>\n<h3 id=\"手动查看你-Git-仓库中的大文件\"><a href=\"#手动查看你-Git-仓库中的大文件\" class=\"headerlink\" title=\"手动查看你 Git 仓库中的大文件\"></a>手动查看你 Git 仓库中的大文件</h3><p><a href=\"https://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/\">Antony Stubbs</a> 写了一个可以很好地完成这个功能的 BASH 脚本。该脚本可以检查你的包文件的内容并列出大文件。在你开始删除文件之前，请执行以下操作获取并安装此脚本：</p>\n<ol>\n<li><p><a href=\"https://confluence.atlassian.com/bitbucket/files/321848291/321979854/1/1360604134990/git_find_big.sh\">下载脚本</a>到你的本地的系统</p>\n</li>\n<li><p>将它放在一个可以访问你的 Git 仓库的易于找到的位置</p>\n</li>\n<li><p>让脚本成为可执行文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 777 git_find_big.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>克隆仓库到你本地系统</p>\n</li>\n<li><p>改变当前目录到你的仓库根目录</p>\n</li>\n<li><p>手动运行 Git 垃圾回收器</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git gc --auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出 .git 文件夹的大小</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注意文件大小，以便随后参考</span></span><br><span class=\"line\"><span class=\"built_in\">du</span> -hs .git/objects</span><br><span class=\"line\">45M .git/objects</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行 <code>git_find_big.sh</code> 脚本来列出你的仓库中的大文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git_find_big.sh</span><br><span class=\"line\">All sizes are <span class=\"keyword\">in</span> kB<span class=\"string\">&#x27;s. The pack column is the size of the object, compressed, inside the pack file.</span></span><br><span class=\"line\"><span class=\"string\">size  pack  SHA                                       location</span></span><br><span class=\"line\"><span class=\"string\">592   580   e3117f48bc305dd1f5ae0df3419a0ce2d9617336  media/img/emojis.jar</span></span><br><span class=\"line\"><span class=\"string\">550   169   b594a7f59ba7ba9daebb20447a87ea4357874f43  media/js/aui/aui-dependencies.jar</span></span><br><span class=\"line\"><span class=\"string\">518   514   22f7f9a84905aaec019dae9ea1279a9450277130  media/images/screenshots/issue-tracker-wiki.jar</span></span><br><span class=\"line\"><span class=\"string\">337   92    1fd8ac97c9fecf74ba6246eacef8288e89b4bff5  media/js/lib/bundle.js</span></span><br><span class=\"line\"><span class=\"string\">240   239   e0c26d9959bd583e5ef32b6206fc8abe5fea8624  media/img/featuretour/heroshot.png</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>大文件都是 JAR 文件，包的大小列是最相关的。aui-dependencies.jar 被压缩到 169kb，但是 emojis.jar 只压缩到 500kb。emojis.jar 就是一个待删除的对象。</p>\n<h3 id=\"运行-filter-branch\"><a href=\"#运行-filter-branch\" class=\"headerlink\" title=\"运行 filter-branch\"></a>运行 filter-branch</h3><p>你可以给这个命令传递一个用于重写 Git 索引的过滤器。例如，一个过滤器可以可以将每个检索的提交删除。这个用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git filter-branch --index-filter <span class=\"string\">&#x27;git rm --cached --ignore-unmatch&amp;nbsp; _pathname_ &#x27;</span> commitHASH</span><br></pre></td></tr></table></figure>\n\n<p><code>--index-filter</code> 选项可以修改仓库的索引，<code>--cached</code> 选项从索引中而不是磁盘来删除文件。这样会更快，因为你不需要在运行这个过滤器前检查每个修订版本。<br><code>git rm</code> 中的 <code>ignore-unmatch</code> 选项可以防止在尝试移走不存在的文件 pathname 的时候命令失败。通过指定一个提交 HASH 值，你可以从每个以这个 HASH 值开始的提交中删除 pathname。要从开始处删除，你可以省略这个参数或者指定为 HEAD。</p>\n<p>如果你的大文件在不同的分支，你将需要通过名字来删除每个文件。如果大文件都在一个单独的分支，你可以直接删除这个分支本身。</p>\n<h4 id=\"选项-1：通过文件名删除文件\"><a href=\"#选项-1：通过文件名删除文件\" class=\"headerlink\" title=\"选项 1：通过文件名删除文件\"></a>选项 1：通过文件名删除文件</h4><p>使用下面的步骤来删除大文件：</p>\n<ol>\n<li><p>使用下面的命令来删除你找到的第一个大文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git filter-branch --index-filter <span class=\"string\">&#x27;git rm --cached --ignore-unmatch filename&#x27;</span> HEAD</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重复步骤 1 找到剩下的每个大文件</p>\n</li>\n<li><p>在你的仓库里更新引用。 <code>filter-branch</code> 会为你原先的引用创建一个 <code>refs/original/</code> 下的备份。一旦你确信已经删除了正确的文件，你可以运行下面的命令来删除备份文件，同时可以让垃圾回收器回收大的对象</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git for-each-ref --format=<span class=\"string\">&quot;%(refname)&quot;</span> refs/original/ | xargs -n 1 git update-ref -d</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"选项-2：直接删除分支\"><a href=\"#选项-2：直接删除分支\" class=\"headerlink\" title=\"选项 2：直接删除分支\"></a>选项 2：直接删除分支</h4><p>如果你所有的大文件都在一个单独的分支上，你可以直接删除这个分支。删除这个分支会自动删除所有的引用。</p>\n<ol>\n<li><p>删除分支</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch -D PROJ567bugfix</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从后面的分支中删除所有的 reflog 引用</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reflog expire --expire=now PROJ567bugfix</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"对不用的数据垃圾回收\"><a href=\"#对不用的数据垃圾回收\" class=\"headerlink\" title=\"对不用的数据垃圾回收\"></a>对不用的数据垃圾回收</h4><ol>\n<li><p>删除从现在到后面的所有 reflog 引用（除非你明确地只在一个分支上操作）</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reflog expire --expire=now --all</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过运行垃圾回收器和删除旧的对象重新打包仓库。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git gc --prune=now</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把你所有的修改推送回仓库</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push --all --force</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确保你所有的标签也是当前最新的</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push --tags --force</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://confluence.atlassian.com/bitbucket/maintaining-a-git-repository-321848291.html\">英文原文地址</a></p>","categories":[{"name":"Git","path":"api/categories/Git.json"}],"tags":[{"name":"Git","path":"api/tags/Git.json"}]}