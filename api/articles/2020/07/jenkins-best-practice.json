{"title":"Jenkins Top 3 best practice","slug":"2020/07/jenkins-best-practice","date":"2020-07-03T10:57:02.000Z","updated":"2025-06-22T15:35:49.571Z","comments":true,"path":"api/articles/2020/07/jenkins-best-practice.json","excerpt":"I am Xianpeng, a build engineer. Today, I am going to share with you three Jenkins Practice.I will talk about Configuration as code, followed up with shared libraries, and then Multi-Branch Pipeline in the end.Configuration as CodeWhat is Configuration as Code?Configuration as code (CAC) is an approach that managing configuration resources in a bitbucket repositoryWhat are the benefits?First, Jenkins Job Transparency","covers":["/2020/07/jenkins-best-practice/pull-request.png","/2020/07/jenkins-best-practice/multi-branches.png","/2020/07/jenkins-best-practice/multi-pull-request.png"],"content":"<p>I am Xianpeng, a build engineer. Today, I am going to share with you three Jenkins Practice.</p>\n<p>I will talk about Configuration as code, followed up with shared libraries, and then Multi-Branch Pipeline in the end.</p>\n<h2 id=\"Configuration-as-Code\"><a href=\"#Configuration-as-Code\" class=\"headerlink\" title=\"Configuration as Code\"></a>Configuration as Code</h2><p>What is Configuration as Code?</p>\n<p>Configuration as code (CAC) is an approach that managing configuration resources in a bitbucket repository</p>\n<h3 id=\"What-are-the-benefits\"><a href=\"#What-are-the-benefits\" class=\"headerlink\" title=\"What are the benefits?\"></a>What are the benefits?</h3><h4 id=\"First-Jenkins-Job-Transparency\"><a href=\"#First-Jenkins-Job-Transparency\" class=\"headerlink\" title=\"First, Jenkins Job Transparency\"></a>First, Jenkins Job Transparency</h4><span id=\"more\"></span>\n\n<p>To those who have experience with Bamboo jobs, you know how hard it is to grasp the logic from the GUI, this is especially true to people who don’t know the tools very well. So, when we migrated Bamboo jobs to Jenkins, we decided to use Configuration as code, because the code is more readable and very easy for engineers to understand the logic and flow.</p>\n<h4 id=\"Secondly-Traceability\"><a href=\"#Secondly-Traceability\" class=\"headerlink\" title=\"Secondly, Traceability\"></a>Secondly, Traceability</h4><p>Another drawback of configuring Jenkins Jobs through GUI is that it cannot trace the history and see who did what. The ability to see who made changes is very very important for some critical Jenkins jobs, such as build jobs. With Configuration as code, we treat the Jenkins job code the same way as other application code, the benefits are not only on traceability-wise, but also the ability to roll-back to a specific version if needed.</p>\n<h4 id=\"Thirdly-Quick-Recovery\"><a href=\"#Thirdly-Quick-Recovery\" class=\"headerlink\" title=\"Thirdly, Quick Recovery\"></a>Thirdly, Quick Recovery</h4><p>Using Configuration as code has another benefit, which is the ability to quickly recover Jenkins’s job upon hardware issues. However, if Jenkins Job is configured through GUI, when the server that host the Jenkins corrupted, you might at risk of losing everything relates to Jenkins. So, from the business continuity  perspective, it is also suggesting us to use configuration as code.</p>\n<h2 id=\"Jenkins-Shared-Libraries\"><a href=\"#Jenkins-Shared-Libraries\" class=\"headerlink\" title=\"Jenkins Shared Libraries\"></a>Jenkins Shared Libraries</h2><p>Just like writing any application code, that we need to create functions, subroutines for reuse and sharing purpose. The same logic applies to the Jenkins configuration code. Functionalities such as sending emails, printing logs, deploying the build to FTP&#x2F;Artifactory can be put into Jenkins Shared Libraries. Jenkins Shared Libraries is managed in Bitbucket.</p>\n<p>So, let’s take a look, …</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">xshen@localhost MINGW64 /c/workspace/cicd/src/org/devops (develop)</span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> -l</span><br><span class=\"line\">total 28</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 5658 Jun 18 09:23 email.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089  898 Jun 13 20:05 git.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 1184 Jun  8 12:10 opensrc.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 1430 Jul  3 10:33 polaris.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 2936 Jul  3 10:32 trigger.groovy</span><br><span class=\"line\">drwxr-xr-x 1 xshen 1049089    0 Jun  8 12:10 utils/</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089  787 May 12 13:24 utils.groovy</span><br></pre></td></tr></table></figure>\n\n<p>As you can see, these groovy files are so-called shared libraries that complete works such as sending emails, git operations, updating opensource and so on.<br>So, it is becoming very clear why we want to use shared libraries because it can reduce duplicate code.</p>\n<p>It is also easier to maintain because instead of updating several places, we just need to update the shared libraries if any changes required. The last but not least, it encourages reuse and sharing cross teams. For example, the shared libraries I created are also used other team.</p>\n<h2 id=\"Multi-branch-pipeline\"><a href=\"#Multi-branch-pipeline\" class=\"headerlink\" title=\"Multi-branch pipeline\"></a>Multi-branch pipeline</h2><p>Next, Multi-branch pipeline. Some of you may have seen the same diagram like this.</p>\n<p><img src=\"/2020/07/jenkins-best-practice/pull-request.png\" alt=\"Pull Request diagram\"></p>\n<p>In this picture, the pull request will trigger an automatic build, which is very helpful to engineers because their changes will not be merged to the main branch unless it passes the build test and smoke test.</p>\n<p>So, I will share more detailed information here with you.</p>\n<p>The thing works behind the scene is called Jenkins Multi-branch Pipeline. Before getting into the details, let’s first see what it looks like.</p>\n<p><img src=\"/2020/07/jenkins-best-practice/multi-branches.png\" alt=\"Multi-Branch Pipeline Branches\"></p>\n<blockquote>\n<p>Note: If your branch or Pull Request has been deleted, the branch or Pull Request will either be removed from the multi-branch Job or show a crossed-out status as shown above, this depending on your Jenkins setting.</p>\n</blockquote>\n<p><img src=\"/2020/07/jenkins-best-practice/multi-pull-request.png\" alt=\"Multi-Branch Pipeline Pull Requests\"></p>\n<p>So, as you can see from this page, there are multi Jenkins jobs. That is because for each bugfix or feature branch in Bitbucket, this multi-branch pipeline will automatically create a Jenkins job for them.</p>\n<p>So, when developers complete their works, they can use these Jenkins jobs to create official build by themselves without the need of involving a build engineer. However, this was not the case in the past. At the time that we did not have these self-service jobs, developers always ask help from me, the build engineer to create a build for them. We have around twenty U2 developers in the team, you can image the efforts needed to satisfy these requirements.</p>\n<p>So, I just covered the first benefit of this multi-branch pipeline, which creates a self-service for the team, save their time, save my time.</p>\n<p>Another benefit of this self-service build and install is that our main branch will be more stable and save us from the time spent on investigating whose commit was problematic because only changes passed build, install and smoke test will be merged into the main branch.</p>\n<p>Now, you may wonder the value of this work, like how many issues have been discovered by this auto build and install test.</p>\n<p>Taking our current development as an example, there were about 30 pull requests merged last month, and six of them were found has built problems on some platforms.</p>\n<p>As you all know, the cost of quality will be very low if we can find issues during the development phase, rather than being found by QA, Support or even customer.</p>\n<p>Please comments in case you have any questions.</p>\n","more":"<p>To those who have experience with Bamboo jobs, you know how hard it is to grasp the logic from the GUI, this is especially true to people who don’t know the tools very well. So, when we migrated Bamboo jobs to Jenkins, we decided to use Configuration as code, because the code is more readable and very easy for engineers to understand the logic and flow.</p>\n<h4 id=\"Secondly-Traceability\"><a href=\"#Secondly-Traceability\" class=\"headerlink\" title=\"Secondly, Traceability\"></a>Secondly, Traceability</h4><p>Another drawback of configuring Jenkins Jobs through GUI is that it cannot trace the history and see who did what. The ability to see who made changes is very very important for some critical Jenkins jobs, such as build jobs. With Configuration as code, we treat the Jenkins job code the same way as other application code, the benefits are not only on traceability-wise, but also the ability to roll-back to a specific version if needed.</p>\n<h4 id=\"Thirdly-Quick-Recovery\"><a href=\"#Thirdly-Quick-Recovery\" class=\"headerlink\" title=\"Thirdly, Quick Recovery\"></a>Thirdly, Quick Recovery</h4><p>Using Configuration as code has another benefit, which is the ability to quickly recover Jenkins’s job upon hardware issues. However, if Jenkins Job is configured through GUI, when the server that host the Jenkins corrupted, you might at risk of losing everything relates to Jenkins. So, from the business continuity  perspective, it is also suggesting us to use configuration as code.</p>\n<h2 id=\"Jenkins-Shared-Libraries\"><a href=\"#Jenkins-Shared-Libraries\" class=\"headerlink\" title=\"Jenkins Shared Libraries\"></a>Jenkins Shared Libraries</h2><p>Just like writing any application code, that we need to create functions, subroutines for reuse and sharing purpose. The same logic applies to the Jenkins configuration code. Functionalities such as sending emails, printing logs, deploying the build to FTP&#x2F;Artifactory can be put into Jenkins Shared Libraries. Jenkins Shared Libraries is managed in Bitbucket.</p>\n<p>So, let’s take a look, …</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">xshen@localhost MINGW64 /c/workspace/cicd/src/org/devops (develop)</span><br><span class=\"line\">$ <span class=\"built_in\">ls</span> -l</span><br><span class=\"line\">total 28</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 5658 Jun 18 09:23 email.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089  898 Jun 13 20:05 git.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 1184 Jun  8 12:10 opensrc.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 1430 Jul  3 10:33 polaris.groovy</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089 2936 Jul  3 10:32 trigger.groovy</span><br><span class=\"line\">drwxr-xr-x 1 xshen 1049089    0 Jun  8 12:10 utils/</span><br><span class=\"line\">-rw-r--r-- 1 xshen 1049089  787 May 12 13:24 utils.groovy</span><br></pre></td></tr></table></figure>\n\n<p>As you can see, these groovy files are so-called shared libraries that complete works such as sending emails, git operations, updating opensource and so on.<br>So, it is becoming very clear why we want to use shared libraries because it can reduce duplicate code.</p>\n<p>It is also easier to maintain because instead of updating several places, we just need to update the shared libraries if any changes required. The last but not least, it encourages reuse and sharing cross teams. For example, the shared libraries I created are also used other team.</p>\n<h2 id=\"Multi-branch-pipeline\"><a href=\"#Multi-branch-pipeline\" class=\"headerlink\" title=\"Multi-branch pipeline\"></a>Multi-branch pipeline</h2><p>Next, Multi-branch pipeline. Some of you may have seen the same diagram like this.</p>\n<p><img src=\"/2020/07/jenkins-best-practice/pull-request.png\" alt=\"Pull Request diagram\"></p>\n<p>In this picture, the pull request will trigger an automatic build, which is very helpful to engineers because their changes will not be merged to the main branch unless it passes the build test and smoke test.</p>\n<p>So, I will share more detailed information here with you.</p>\n<p>The thing works behind the scene is called Jenkins Multi-branch Pipeline. Before getting into the details, let’s first see what it looks like.</p>\n<p><img src=\"/2020/07/jenkins-best-practice/multi-branches.png\" alt=\"Multi-Branch Pipeline Branches\"></p>\n<blockquote>\n<p>Note: If your branch or Pull Request has been deleted, the branch or Pull Request will either be removed from the multi-branch Job or show a crossed-out status as shown above, this depending on your Jenkins setting.</p>\n</blockquote>\n<p><img src=\"/2020/07/jenkins-best-practice/multi-pull-request.png\" alt=\"Multi-Branch Pipeline Pull Requests\"></p>\n<p>So, as you can see from this page, there are multi Jenkins jobs. That is because for each bugfix or feature branch in Bitbucket, this multi-branch pipeline will automatically create a Jenkins job for them.</p>\n<p>So, when developers complete their works, they can use these Jenkins jobs to create official build by themselves without the need of involving a build engineer. However, this was not the case in the past. At the time that we did not have these self-service jobs, developers always ask help from me, the build engineer to create a build for them. We have around twenty U2 developers in the team, you can image the efforts needed to satisfy these requirements.</p>\n<p>So, I just covered the first benefit of this multi-branch pipeline, which creates a self-service for the team, save their time, save my time.</p>\n<p>Another benefit of this self-service build and install is that our main branch will be more stable and save us from the time spent on investigating whose commit was problematic because only changes passed build, install and smoke test will be merged into the main branch.</p>\n<p>Now, you may wonder the value of this work, like how many issues have been discovered by this auto build and install test.</p>\n<p>Taking our current development as an example, there were about 30 pull requests merged last month, and six of them were found has built problems on some platforms.</p>\n<p>As you all know, the cost of quality will be very low if we can find issues during the development phase, rather than being found by QA, Support or even customer.</p>\n<p>Please comments in case you have any questions.</p>","categories":[{"name":"Jenkins","path":"api/categories/Jenkins.json"}],"tags":[{"name":"DevOps","path":"api/tags/DevOps.json"},{"name":"Jenkins","path":"api/tags/Jenkins.json"}]}